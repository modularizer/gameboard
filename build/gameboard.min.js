// src/js/gameboard.js?v20230820T20:59:36.359Z
import * as THREE7 from "three";

// src/js/utils/tabID.js
var tabs = localStorage.getItem("tabs");
var existingTabs = tabs ? JSON.parse(tabs) : [];
if (existingTabs.length > 10) {
  existingTabs = [];
  localStorage.removeItem("tabs");
}
/* @__PURE__ */ console.log("Existing tabs: ", existingTabs, localStorage.getItem("tabs"));
var randomTabID = Math.floor(Math.random() * 1e9);
var tabID = Math.max(...existingTabs.map((v) => 1 * v.split("_")[0]), 0) + 1;
var fullTabID = tabID + "_" + randomTabID;
existingTabs.push(fullTabID);
localStorage.setItem("tabs", JSON.stringify(existingTabs));
window.addEventListener("beforeunload", function() {
  tabs = localStorage.getItem("tabs");
  existingTabs = tabs ? JSON.parse(tabs) : [];
  existingTabs = existingTabs.filter((v) => v !== fullTabID);
  localStorage.setItem("tabs", JSON.stringify(existingTabs));
});

// src/js/utils/deferredPromise.js
var DeferredPromise = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// src/js/utils/mqtt-rtc.js
var baseTopic = location.hostname + location.pathname.replace(/index\.html$/, "").replace(/[^a-zA-Z0-9]/g, "");
var MQTTRTCClient = class {
  constructor(config) {
    let { topic, name, options, handlers, mqttOnly } = config || {};
    this.handlers = Object.assign(this.handlers, handlers);
    this.mqttOnly = mqttOnly;
    let n = localStorage.getItem("name");
    if (n && n.startsWith("anon")) {
      n = null;
    }
    this.name = name || n || "anon" + Math.floor(Math.random() * 1e3);
    localStorage.setItem("name", this.name);
    this.name += "_" + tabID;
    this.tabID = tabID;
    this.topic = baseTopic + (topic || location.hash.replace("#", "").replace(/[^a-zA-Z0-9]/g, ""));
    this.load = this.load.bind(this);
    this.post = this.post.bind(this);
    this.send = this.send.bind(this);
    this.sendDM = this.sendDM.bind(this);
    this.sendChat = this.sendChat.bind(this);
    this.getRTCConnections = this.getRTCConnections.bind(this);
    this.onMQTTConnect = this.onMQTTConnect.bind(this);
    this.onMQTTMessage = this.onMQTTMessage.bind(this);
    this.beforeunload = this.beforeunload.bind(this);
    for (let [k, v] of Object.entries(this.mqttHandlers)) {
      this.mqttHandlers[k] = v.bind(this);
    }
    for (let [k, v] of Object.entries(this.handlers)) {
      this.handlers[k] = v.bind(this);
    }
    this.rollCalls = {};
    this.activeUsers = [];
    this.activeRTCConnections = [];
    this.rtcConnections = {};
    this.load();
  }
  load() {
    if (!window.mqtt) {
      console.warn("MQTT not loaded yet");
      setTimeout(this.load.bind(this), 100);
      return;
    }
    this.client = mqtt.connect("wss://public:public@public.cloud.shiftr.io", { clientId: "javascript" });
    this.client.on("connect", this.onMQTTConnect.bind(this));
    this.client.on("message", this.onMQTTMessage.bind(this));
    window.r = this;
    window.c = this.client;
    window.addEventListener("beforeunload", this.beforeunload.bind(this));
  }
  onMQTTConnect() {
    this.client.subscribe(this.topic);
    let t = Date.now();
    this.rollCalls[t] = [];
    this.post(t, "rollCall");
  }
  onMQTTMessage(t, payloadString) {
    if (t === this.topic) {
      let payload = JSON.parse(payloadString);
      if (payload.sender === this.name) {
        return;
      }
      let type = payload.type;
      if (this.mqttHandlers[type]) {
        this.mqttHandlers[type](payload);
      } else if (this.handlers[type]) {
        this.handlers[type](payload.data, payload.sender);
      } else {
        console.warn("Unhandled message type: " + type, payload);
      }
    }
  }
  beforeunload() {
    this.send("left", "connection");
    this.post("Goodbye", "goodbye");
  }
  post(message, type = "chat") {
    let payload = {
      sender: this.name,
      timestamp: Date.now(),
      type,
      data: message
    };
    let payloadString = JSON.stringify(payload);
    this.client.publish(this.topic, payloadString);
  }
  mqttHandlers = {
    rollCall: (payload) => {
      /* @__PURE__ */ console.log("Roll call from " + payload.sender, payload, payload.data);
      let t = payload.data;
      let newRollCall = !this.rollCalls[t];
      if (!this.rollCalls[t]) {
        this.rollCalls[t] = [];
      }
      if (!this.activeUsers.includes(payload.sender)) {
        this.activeUsers.push(payload.sender);
        if (this.handlers["activeUsers"]) {
          this.handlers["activeUsers"](this.activeUsers);
        }
      }
      if (!this.rollCalls[t].includes(payload.sender)) {
        this.rollCalls[t].push(payload.sender);
        if (!this.mqttOnly) {
          if (this.rtcConnections[payload.sender] && this.rtcConnections[payload.sender].peerConnection.connectionState === "connected") {
            console.warn("Already connected to " + payload.sender);
          } else {
            if (this.rtcConnections[payload.sender]) {
              console.warn("Already have a connection to " + payload.sender + " but it's not connected.", this.rtcConnections[payload.sender].peerConnection.connectionState, "  Closing and reopening.");
              this.rtcConnections[payload.sender].close();
            }
            if (newRollCall) {
              this.rtcConnections[payload.sender] = new RTCConnection(this.name, payload.sender, this, this.handlers);
              this.rtcConnections[payload.sender].sendOffer();
            }
          }
        }
        this.post(t, "rollCall");
      } else {
        console.warn("Already received roll call from " + payload.sender, t);
      }
      if (!this.rollCalls[t]) {
        this.rollCalls[t] = [];
      }
    },
    goodbye: (payload) => {
      this.activeUsers = this.activeUsers.filter((name) => name !== payload.sender);
      if (this.handlers["activeUsers"]) {
        this.handlers["activeUsers"](this.activeUsers);
      }
      this.activeRTCConnections = this.activeRTCConnections.filter((name) => name !== payload.sender);
      if (this.rtcConnections[payload.sender]) {
        console.warn("Closing connection to " + payload.sender + " because they left.");
        this.rtcConnections[payload.sender].close();
        delete this.rtcConnections[payload.sender];
      }
    },
    RTCoffer: (payload) => {
      if (this.mqttOnly) {
        return;
      }
      /* @__PURE__ */ console.log("received RTCoffer", payload);
      let { offer, target } = payload.data;
      if (target != this.name) {
        return;
      }
      ;
      if (this.rtcConnections[payload.sender]) {
        console.warn("Already have a connection to " + payload.sender + ". Closing and reopening.");
        this.rtcConnections[payload.sender].close();
      }
      this.rtcConnections[payload.sender] = new RTCConnection(this.name, payload.sender, this, this.handlers);
      this.rtcConnections[payload.sender].respondToOffer(offer);
    },
    RTCanswer: (payload) => {
      if (this.mqttOnly) {
        return;
      }
      /* @__PURE__ */ console.log("received RTCanswer", payload);
      let { answer, target } = payload.data;
      if (target != this.name) {
        return;
      }
      ;
      let rtcConnection = this.rtcConnections[payload.sender];
      if (!rtcConnection) {
        console.error("No connection found for " + payload.sender);
        return;
      }
      rtcConnection.receiveAnswer(answer);
    },
    RTCiceCandidate: (payload) => {
      if (this.mqttOnly) {
        return;
      }
      let rtcConnection = this.rtcConnections[payload.sender];
      if (!rtcConnection) {
        console.error("No connection found for " + payload.sender);
        this.rtcConnections[payload.sender] = new RTCConnection(this.name, payload.sender, this, this.handlers);
        let rtcConnection2 = this.rtcConnections[payload.sender];
        rtcConnection2.sendOffer();
      }
      rtcConnection.onReceivedIceCandidate(payload.data);
    }
  };
  handlers = {
    connection(data, sender) {
      /* @__PURE__ */ console.log("connection", data, sender);
      if (this.handlers["RTCconnection"]) {
        this.handlers["RTCconnection"](data, sender);
      }
      if (data === "joined") {
        if (!this.activeUsers.includes(sender)) {
          /* @__PURE__ */ console.log("Received connection from", sender);
          this.activeUsers.push(sender);
        } else {
          console.warn("Already received connection from " + sender);
        }
        if (!this.activeRTCConnections.includes(sender)) {
          this.activeRTCConnections.push(sender);
          this.post("joined", "connection", sender);
        }
      } else if (data === "left") {
        /* @__PURE__ */ console.log("Received disconnection from", sender);
        this.activeUsers = this.activeUsers.filter((name) => name !== sender);
      }
      if (this.handlers["activeUsers"]) {
        this.handlers["activeUsers"](this.activeUsers);
      }
    }
  };
  getRTCConnections(users) {
    users = users || this.activeUsers;
    if (typeof users === "string") {
      users = [users];
    }
    return users.map((name) => this.rtcConnections[name]).filter((connection) => connection);
  }
  send(data, type, users) {
    let connections = this.getRTCConnections(users);
    for (let connection of connections) {
      connection.send(data, type);
    }
  }
  sendDM(message, target) {
    this.send(message, "dm", target);
  }
  sendChat(message) {
    this.send(message, "chat");
  }
};
var RTCConnection = class {
  rtcConfiguration = { "iceServers": [{ "urls": "stun:stun.l.google.com:19302" }] };
  constructor(name, target, mqttClient, handlers) {
    /* @__PURE__ */ console.log("making RTCConnection", handlers);
    this.name = name;
    this.target = target;
    this.mqttClient = mqttClient;
    this.handlers = handlers;
    this.dataChannels = {};
    this.peerConnection = new RTCPeerConnection(this.rtcConfiguration);
    this.peerConnection = new RTCPeerConnection(this.rtcConfiguration);
    this.peerConnection.onicecandidate = this.onicecandidate.bind(this);
    this.dataChannelDeferredPromises = Object.fromEntries(Object.entries(this.handlers).map(([name2, handler]) => [name2, new DeferredPromise()]));
    this.loadPromise = Promise.all(Object.values(this.dataChannelDeferredPromises).map((deferredPromise) => deferredPromise.promise));
    this.loaded = false;
    this.loadPromise.then((() => {
      this.loaded = true;
    }).bind(this));
    this.peerConnection.ondatachannel = ((event2) => {
      this.registerDataChannel(event2.channel);
    }).bind(this);
  }
  sendOffer() {
    this.setupDataChannels();
    this.peerConnection.createOffer().then((offer) => this.peerConnection.setLocalDescription(offer)).then(() => {
      /* @__PURE__ */ console.log("Sending offer to " + this.target);
      this.mqttClient.post({ "offer": this.peerConnection.localDescription, "target": this.target }, "RTCoffer");
    });
  }
  registerDataChannel(dataChannel) {
    dataChannel.onmessage = ((e) => {
      this.onmessage(e, dataChannel.label);
    }).bind(this);
    dataChannel.onerror = ((e) => {
      this.dataChannelDeferredPromises[dataChannel.label].reject(e);
      this.ondatachannelerror(e, dataChannel.label);
    }).bind(this);
    dataChannel.onopen = ((e) => {
      this.dataChannelDeferredPromises[dataChannel.label].resolve(e);
    }).bind(this);
    this.dataChannels[dataChannel.label] = dataChannel;
  }
  setupDataChannels() {
    for (let [name, dataChannelHandler] of Object.entries(this.handlers)) {
      let dataChannel = this.peerConnection.createDataChannel(name);
      this.registerDataChannel(dataChannel);
    }
  }
  respondToOffer(offer) {
    this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer)).then(() => this.peerConnection.createAnswer()).then((answer) => this.peerConnection.setLocalDescription(answer)).then((answer) => {
      this.mqttClient.post({
        "answer": this.peerConnection.localDescription,
        "target": this.target
      }, "RTCanswer");
    });
  }
  receiveAnswer(answer) {
    if (this.peerConnection.signalingState !== "have-local-offer") {
      console.warn("Wrong state " + this.peerConnection.signalingState);
      return;
    }
    this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    this.loadPromise.then((() => this.send("joined", "connection")).bind(this));
  }
  dm(data) {
    this.send(data, "dm");
  }
  send(data, type) {
    try {
      let d = this.handlers[type].raw ? data : JSON.stringify(data);
      this.sendRaw(d, type);
    } catch (e) {
      console.error("error sending", type, this.handlers);
    }
  }
  sendRaw(d, type) {
    let dataChannel = this.dataChannels[type];
    if (!dataChannel) {
      if (this.handlers[type]) {
        console.warn("handler found for type", type, "but no data channel");
      }
      console.warn("No data channel for type", type);
      return;
    }
    if (dataChannel.readyState !== "open") {
      /* @__PURE__ */ console.log("Channel not open", dataChannel.readyState);
      return;
    }
    dataChannel.send(d);
  }
  onmessage(event2, type) {
    let sender = this.target;
    let handler = this.handlers[type];
    let data = handler.raw ? event2.data : JSON.parse(event2.data);
    if (handler) {
      handler(data, sender);
    } else {
      console.warn("No handler for type", type);
    }
  }
  onReceivedIceCandidate(data) {
    this.peerConnection.addIceCandidate(new RTCIceCandidate(data));
  }
  onicecandidate(event2) {
    if (event2.candidate) {
      this.mqttClient.post(event2.candidate, "RTCiceCandidate");
    }
  }
  ondatachannel(event2) {
    let dataChannel = event2.channel;
    this.dataChannels[event2.name] = dataChannel;
    dataChannel.onmessage = this.onmessage.bind(this);
  }
  ondatachannelerror(error, channelName) {
  }
  close() {
    if (this.closed) {
      return;
    }
    this.peerConnection.close();
    this.closed = true;
    this.peerConnection = null;
  }
};

// src/js/utils/rtcAudio.js
var WebRTCAudioChannel = class {
  constructor(rtcClient, users) {
    this.users = users;
    this.handleIncomingAudioData = this.handleIncomingAudioData.bind(this);
    this.mute = this.mute.bind(this);
    this.unmute = this.unmute.bind(this);
    this.startStreaming = this.startStreaming.bind(this);
    this.stopStreaming = this.stopStreaming.bind(this);
    this.send = this.send.bind(this);
    this.handler = this.handleIncomingAudioData;
    this.handleIncomingAudioData.raw = true;
    this.sourceNode = null;
    this.processorNode = null;
    this.streaming = false;
    this.muted = true;
    this.playing = false;
    this.rtcClient = rtcClient;
    this.audioContext = new AudioContext({ sampleRate: this.config.sampleRate });
    this.audioContext.audioWorklet.addModule("./src/js/utils/audio-processor.js").then(() => {
    });
    document.body.addEventListener("click", () => {
      if (this.audioContext.state === "suspended") {
        this.audioContext.resume();
      }
    });
  }
  set rtcClient(rtcClient) {
    this._rtcClient = rtcClient;
    if (rtcClient && rtcClient.handlers) {
      rtcClient.handlers.audio = this.handler;
      rtcClient.startStreaming = this.startStreaming.bind(this);
      rtcClient.stopStreaming = this.stopStreaming.bind(this);
      rtcClient.mute = this.mute.bind(this);
      rtcClient.unmute = this.unmute.bind(this);
    }
  }
  get rtcClient() {
    return this._rtcClient;
  }
  send(audioDataBuffer) {
    this.rtcClient.send(audioDataBuffer, "audio", this.users);
  }
  handleIncomingAudioData(data, sender) {
    if (this.muted)
      return;
    const audioData = new Float32Array(data);
    const audioBuffer = this.audioContext.createBuffer(1, audioData.length, this.audioContext.sampleRate);
    audioBuffer.copyToChannel(audioData, 0);
    const audioSource = this.audioContext.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(this.audioContext.destination);
    audioSource.start();
  }
  config = {
    audio: {
      // Specify other constraints as needed
      sampleSize: 16,
      // bits per sample
      channelCount: 1,
      // stereo
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      latency: 0,
      // optimum latency
      googAutoGainControl: true,
      googNoiseSuppression: true,
      googHighpassFilter: true,
      googTypingNoiseDetection: true,
      bitrate: 8e3 * 16
    },
    sampleRate: 8e3,
    // Sample rate in Hz, common values are 44100 or 48000 Hz
    freq: 800,
    // Frequency for bandpass filter, commonly between 300 to 3400 Hz for voice
    q: 1,
    // Quality factor for bandpass filter, ranges from 0.001 to 100; lower values less resonant
    threshold: -40,
    // Compressor threshold in dB, typical range from -100 to 0 dB; sets level where compression begins
    knee: 10,
    // Compressor knee in dB, typical range from 0 to 40 dB; higher values result in a softer knee and smoother transition
    ratio: 5,
    // Compression ratio, typical range from 1 (no compression) to 20 (hard compression); higher values reduce dynamic range more aggressively
    attack: 1e-4,
    // Attack time in seconds, typical range from 0.0001 to 1 s; sets how quickly compression begins once threshold is reached
    release: 0.1,
    // Release time in seconds, typical range from 0.01 to 1 s; sets how quickly compression stops after signal drops below threshold
    delay: 1 * (localStorage.getItem("delay") || 0)
    // Delay in seconds, typically between 0 to whatever latency is acceptable; represents a simple latency delay, often used to align signals
  };
  // Method to start streaming
  startStreaming() {
    if (this.streaming)
      return;
    /* @__PURE__ */ console.log("Starting streaming");
    navigator.mediaDevices.getUserMedia({ audio: this.config.audio }).then((stream) => {
      /* @__PURE__ */ console.log("Setting up audio processing", stream);
      this.sourceNode = this.audioContext.createMediaStreamSource(stream);
      const biquadFilter = this.audioContext.createBiquadFilter();
      biquadFilter.type = "bandpass";
      biquadFilter.frequency.value = this.config.freq;
      biquadFilter.Q.value = this.config.q;
      const compressor = this.audioContext.createDynamicsCompressor();
      compressor.threshold.value = this.config.threshold;
      compressor.knee.value = this.config.knee;
      compressor.ratio.value = this.config.ratio;
      compressor.attack.value = this.config.attack;
      compressor.release.value = this.config.release;
      this.processorNode = new AudioWorkletNode(this.audioContext, "audio-processor");
      this.processorNode.port.onmessage = (event2) => {
        const audioData = new Float32Array(event2.data);
        this.send(audioData.buffer);
      };
      const delay = this.audioContext.createDelay(5);
      delay.delayTime.value = this.config.delay;
      this.sourceNode.connect(delay);
      delay.connect(biquadFilter);
      biquadFilter.connect(compressor);
      compressor.connect(this.processorNode);
      this.startStreamingSubtitles();
      this.mediaStream = stream;
      this.streaming = true;
    }).catch((error) => console.error("Error accessing microphone:", error));
  }
  // Method to stop streaming
  stopStreaming() {
    if (!this.streaming)
      return;
    this.sourceNode.disconnect();
    this.mediaStream.getTracks().forEach((track) => track.stop());
    this.stopStreamingSubtitles();
    this.streaming = false;
  }
  startStreamingSubtitles() {
    if ("webkitSpeechRecognition" in window) {
      const recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.onresult = (event2) => {
        let transcript = "";
        for (let i2 = event2.resultIndex; i2 < event2.results.length; i2++) {
          transcript += event2.results[i2][0].transcript;
        }
        this.rtcClient.send(transcript, "subtitles", this.users);
      };
      recognition.start();
    } else {
      console.error("Web Speech API is not supported in this browser.");
    }
  }
  stopStreamingSubtitles() {
    if ("webkitSpeechRecognition" in window) {
      const recognition = new webkitSpeechRecognition();
      recognition.stop();
    }
  }
  mute() {
    this.muted = true;
  }
  unmute() {
    this.muted = false;
  }
};

// src/js/utils/keyListeners.js
var KeyListeners = class {
  constructor(keydownListeners, keyupListeners) {
    this.keydownListeners = keydownListeners;
    this.keyupListeners = keyupListeners;
    this.getKey = this.getKey.bind(this);
    this.keydown = this.keydown.bind(this);
    this.keyup = this.keyup.bind(this);
    this.addTo = this.addTo.bind(this);
    this.key = null;
  }
  addTo(element) {
    element.addEventListener("keydown", this.keydown);
    element.addEventListener("keyup", this.keyup);
  }
  getKey(e) {
    let k = e.key;
    if (e.shiftKey && k != "Shift")
      k = "Shift+" + k;
    if (e.altKey && k != "Alt")
      k = "Alt+" + k;
    if (e.ctrlKey && k != "Control")
      k = "Ctrl+" + k;
    if (e.metaKey && k != "Meta")
      k = "Meta+" + k;
    if (e.fnKey && k != "Fn")
      k = "Fn+" + k;
    return k;
  }
  keydown(e) {
    let k = this.getKey(e);
    this.key = k;
    if (this.keydownListeners[k]) {
      this.keydownListeners[k].bind(this)(e);
    } else if (this.keydownListeners["default"]) {
      this.keydownListeners["default"].bind(this)(e, k);
    }
  }
  keyup(e) {
    this.key = null;
    let k = this.getKey(e);
    if (this.keyupListeners[k]) {
      this.keyupListeners[k].bind(this)(e);
    } else if (this.keyupListeners["default"]) {
      this.keyupListeners["default"].bind(this)(e, k);
    }
  }
};

// src/js/scene.js
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

// src/js/moveable.js
var MoveableItem = class {
  constructor(item) {
    this.item = item;
    this.initialPosition = { x: item.originCube.position.x, y: item.originCube.position.y, z: item.originCube.position.z };
    this.item.clickRelativePosition = null;
    this.item.movestate = {
      animation: {
        started: false,
        rotation: {
          enabled: false,
          cycles: null,
          x: 0,
          y: 0,
          z: 0
        },
        translation: {
          enabled: false,
          cycles: null,
          x: 0,
          y: 0,
          z: 0
        },
        lastMoveTime: null,
        lastRotationTime: null,
        lastTranslationTime: null
      }
    };
    this.item.reset = this.reset.bind(this);
    this.item.jumpTo = this.jumpTo.bind(this);
    this.item.moveTo = this.moveTo.bind(this);
    this.item.move = this.move.bind(this);
    this.item.setRotation = this.setRotation.bind(this);
    this.item.spinTo = this.spinTo.bind(this);
    this.item.spin = this.spin.bind(this);
    this.item.startRotation = this.startRotation.bind(this);
    this.item.stopRotation = this.stopRotation.bind(this);
    this.item.startTranslation = this.startTranslation.bind(this);
    this.item.stopTranslation = this.stopTranslation.bind(this);
    this.item.moveFrame = this.moveFrame.bind(this);
    this.item.rotationFrame = this.rotationFrame.bind(this);
    this.item.translationFrame = this.translationFrame.bind(this);
    this.item.flip = this.flip.bind(this);
    return this.item;
  }
  reset() {
    this.item.originCube.position.x = this.initialPosition.x;
    this.item.originCube.position.y = this.initialPosition.y;
    this.item.originCube.position.z = this.initialPosition.z;
    this.item.movestate = {
      animation: {
        rotation: {
          enabled: false,
          x: 0,
          y: 0,
          z: 0
        },
        translation: {
          enabled: false,
          x: 0,
          y: 0,
          z: 0
        }
      }
    };
  }
  flip() {
    this.item.rotation.x += Math.PI;
  }
  jumpTo(x, y, z) {
    this.item.originCube.position.x = x;
    this.item.originCube.position.y = Math.max(y, 0);
    this.item.originCube.position.z = z;
  }
  moveTo(x, y, z, duration, speed = 0.01) {
    let dx = x - this.item.originCube.position.x;
    let dy = y - Math.max(this.item.originCube.position.y, 0);
    let dz = z - this.item.originCube.position.z;
    this.move(dx, dy, dz, duration, speed);
  }
  move(dx, dy, dz, duration, speed = 0.01) {
    dy = Math.max(dy, -this.item.originCube.position.y);
    let distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let fps = 60;
    if (duration) {
      speed = distance / (duration * fps);
    }
    let sx = speed * dx / distance;
    let sy = speed * dy / distance;
    let sz = speed * dz / distance;
    this.item.movestate.animation.translation = {
      enabled: true,
      cycles: Math.floor(distance / speed),
      x: sx,
      y: sy,
      z: sz
    };
  }
  spinTo(x, y, z, duration, speed = 0.02) {
    let dx = x - this.item.rotation.x;
    let dy = y - this.item.rotation.y;
    let dz = z - this.item.rotation.z;
    this.spin(dx, dy, dz, duration, speed);
  }
  spin(dx, dy, dz, duration, speed = 0.02) {
    if (duration) {
      speed = dx / (duration * 60);
    }
    let distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let sx = speed * dx / distance;
    let sy = speed * dy / distance;
    let sz = speed * dz / distance;
    this.item.movestate.animation.rotation = {
      enabled: true,
      cycles: Math.floor(distance / speed),
      x: sx,
      y: sy,
      z: sz
    };
  }
  setRotation(x, y, z) {
    this.item.pivot.rotation.x = x;
    this.item.pivot.rotation.y = y;
    this.item.pivot.rotation.z = z;
  }
  translate(x, y, z) {
    this.item.originCube.position.x += x;
    this.item.originCube.position.y = Math.max(0, this.item.originCube.position.y + y);
    this.item.originCube.position.z += z;
  }
  rotate(x, y, z) {
    this.item.pivot.rotation.x += x;
    this.item.pivot.rotation.y += y;
    this.item.pivot.rotation.z += z;
  }
  startRotation(speedx = 0.02, speedy = 0.01, speedz = 0, cycles = null) {
    this.item.movestate.animation.rotation = {
      enabled: true,
      cycles,
      x: speedx,
      y: speedy,
      z: speedz
    };
  }
  stopRotation() {
    this.item.movestate.animation.rotation.enabled = false;
  }
  startTranslation(speedx = 0.02, speedy = 0.01, speedz = 0, cycles = null) {
    this.item.movestate.animation.translation = {
      enabled: true,
      x: speedx,
      y: speedy,
      z: speedz
    };
  }
  stopTranslation() {
    this.item.movestate.animation.translation.enabled = false;
  }
  moveFrame(t) {
    this.item.movestate.animation.lastMoveTime = t;
    if (this.item.movestate.animation.rotation.enabled) {
      this.rotationFrame(t);
    }
    if (this.item.movestate.animation.translation.enabled) {
      this.translationFrame(t);
    }
  }
  rotationFrame(t) {
    this.item.movestate.animation.lastRotationTime = t;
    let r = this.item.movestate.animation.rotation;
    this.rotate(r.x, r.y, r.z);
    if (r.cycles === 0) {
      this.stopRotation();
    } else if (r.cycles != null) {
      r.cycles--;
    }
  }
  translationFrame(t) {
    this.item.movestate.animation.lastTranslationTime = t;
    let tr = this.item.movestate.animation.translation;
    this.translate(tr.x, tr.y, tr.z);
    if (tr.cycles === 0) {
      this.stopTranslation();
    } else if (tr.cycles != null) {
      tr.cycles--;
    }
  }
  onRightClickDown(event2) {
  }
  onRightClickMove(event2) {
  }
  onRightClickUp(event2) {
  }
};

// src/js/utils/mouseListeners.js
var MouseListeners = class {
  constructor(parent) {
    parent.onMouseDown = parent.onMouseDown.bind(parent) || function() {
    };
    parent.onMouseMove = parent.onMouseMove.bind(parent) || function() {
    };
    parent.onMouseUp = parent.onMouseUp.bind(parent) || function() {
    };
    this.parent = parent;
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);
    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchMove = this.onTouchMove.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
  }
  setSimulatedMouseButton(button) {
    this.state.simulatedMouseButton = button;
  }
  addTo(element) {
    element.addEventListener("mousedown", this.onMouseDown.bind(this));
    element.addEventListener("mousemove", this.onMouseMove.bind(this));
    element.addEventListener("mouseup", this.onMouseUp.bind(this));
    element.addEventListener("touchstart", this.onTouchStart.bind(this));
    element.addEventListener("touchmove", this.onTouchMove.bind(this));
    element.addEventListener("touchend", this.onTouchEnd.bind(this));
    element.addEventListener("touchcancel", this.onTouchEnd.bind(this));
    element.addEventListener("dblclick", this.onDblClick.bind(this));
  }
  state = {
    clickedButton: null,
    simulatedMouseButton: null
  };
  onMouseDown(event2, touch) {
    if (event2.button == 2) {
      event2.preventDefault();
    }
    let button = this.state.simulatedMouseButton != null ? this.state.simulatedMouseButtom : event2.button;
    this.state.clickedButton = button;
    this.parent.onMouseDown(event2, button, touch);
  }
  onMouseMove(event2, touch) {
    this.parent.onMouseMove(event2, this.state.clickedButton, touch);
  }
  onMouseUp(event2, touch) {
    let button = this.state.clickedButton;
    this.state.clickedButton = null;
    this.parent.onMouseUp(event2, button, touch);
  }
  onTouchStart(event2) {
    if (event2.touches) {
      event2.clientX = event2.touches[0].clientX;
      event2.clientY = event2.touches[0].clientY;
    }
    this.onMouseDown(event2, true);
  }
  onTouchMove(event2) {
    if (event2.touches) {
      event2.clientX = event2.touches[0].clientX;
      event2.clientY = event2.touches[0].clientY;
    }
    this.onMouseMove(event2, true);
  }
  onTouchEnd(event2) {
    this.onMouseUp(event2, true);
  }
  onTouchCancel(event2) {
    this.onMouseUp(event2, true);
  }
  onDblClick(event2) {
    event2.preventDefault();
    this.parent.onDblClick(event2);
  }
};

// src/js/utils/merge.js
function merge(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        merge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return merge(target, ...sources);
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}

// src/js/scene.js
function toXYZ(v) {
  if (v instanceof THREE.Vector3)
    return [v.x, v.y, v.z];
  if (v instanceof Array)
    return { x: v[0], y: v[1], z: v[2] };
  if (typeof v === "object")
    return v;
}
var CustomScene = class extends THREE.Scene {
  constructor(cameraPosition, lookAt) {
    super();
    this.loaded = false;
    this.loadDeferredPromise = new DeferredPromise();
    this.loadPromise = this.loadDeferredPromise.promise;
    this.sceneLoaded = false;
    this.display = this.display.bind(this);
    this.animate = this.animate.bind(this);
    this.getClickedItem = this.getClickedItem.bind(this);
    this.setCameraMode = this.setCameraMode.bind(this);
    this.configure = this.configure.bind(this);
    this.configCamera = this.configCamera.bind(this);
    this.configRenderer = this.configRenderer.bind(this);
    this.configAxesHelper = this.configAxesHelper.bind(this);
    this.configGridHelper = this.configGridHelper.bind(this);
    this.configFloor = this.configFloor.bind(this);
    this.configLights = this.configLights.bind(this);
    this.sendItemUpdate = this.sendItemUpdate.bind(this);
    this.receiveItemUpdate = this.receiveItemUpdate.bind(this);
    this.log = this.log.bind(this);
    this.onlog = this.onlog.bind(this);
    this.cacheFullState = this.cacheFullState.bind(this);
    this.getFullState = this.getFullState.bind(this);
    this.loadCachedState = this.loadCachedState.bind(this);
    this.fullState = {};
    this.keyListeners.addTo(window);
    this.mouseListeners = new MouseListeners(this);
    this.mouseListeners.addTo(window);
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector3(0, 0, 0.5);
    this.offset = new THREE.Vector3();
    this.renderer = new THREE.WebGLRenderer();
    this.gridHelper = new THREE.GridHelper();
    this.axesHelper = new THREE.AxesHelper();
    this.configure(this.config, cameraPosition, lookAt);
    super.add(this.gridHelper);
    super.add(this.axesHelper);
    let d = {
      "camera": this.configCamera,
      "renderer": this.configRenderer,
      "axes": this.configAxesHelper,
      "grid": this.configGridHelper,
      "floor": this.configFloor,
      "lights": this.configLights
    };
    this._config = new Proxy(this.config, {
      get: (target, key) => {
        let value = target[key];
        if (typeof value === "object") {
          return new Proxy(target[key], {
            get: (target2, key2) => {
              let value2 = target2[key2];
              if (typeof value2 === "object") {
                return new Proxy(value2, {
                  get: (target3, key3) => target3[key3],
                  set: (target3, key3, value3) => {
                    target3[key3] = value3;
                    d[key](target2);
                    return true;
                  }
                });
              }
              return value2;
            },
            set: (target2, key2, value2) => {
              target2[key2] = value2;
              d[key](target2);
              return true;
            }
          });
        }
        return value;
      },
      set: (target, key, value) => {
        d[key](value);
        return true;
      }
    });
    this.loadPromise.then(this.loadCachedState.bind(this));
    this.loadPromise.then(() => {
      console.timeEnd("load");
    });
  }
  // key listeners
  keyListeners = new KeyListeners({
    "ArrowUp": () => {
      if (this.state.selectedItem) {
        this.state.selectedItem.position.z -= this.config.speed;
      } else {
        this.camera.position.x += this.config.speed;
      }
    },
    "ArrowDown": () => {
      if (this.state.selectedItem) {
        this.state.selectedItem.position.z += this.config.speed;
      } else {
        this.camera.position.x -= this.config.speed;
      }
    },
    "ArrowLeft": () => {
      if (this.state.selectedItem) {
        this.state.selectedItem.position.x -= this.config.speed;
      } else {
        this.camera.position.y -= this.config.speed;
      }
    },
    "ArrowRight": () => {
      if (this.state.selectedItem) {
        this.state.selectedItem.position.x += this.config.speed;
      } else {
        this.camera.position.y += this.config.speed;
      }
    },
    "r": () => {
      if (!this.state.dragging) {
        this.state.animate = !this.state.animate;
      }
      if (this.state.selectedItem) {
        let item = this.state.selectedItem;
        this.state.selectedItem.pivot.rotateY(Math.PI / 2);
        this.itemRotateEnd(item);
        if (item.onRightClickUp)
          item.onRightClickUp(event);
      }
    },
    "x": () => {
      this.reset();
    },
    "p": () => {
      this.state.moveMode = "y";
    },
    "n": () => {
      this.state.moveMode = "normal";
    },
    "Control": () => {
      this.state.clickMode = "right";
    },
    "Alt": () => {
      this.state.clickMode = "middle";
    },
    "default": (e, k) => {
      console.warn("Unhandled key:", k);
      if (this.state.selectedItem)
        this.state.selectedItem.keydown(e, k);
    }
  }, {
    "Control": () => {
      this.state.clickMode = "left";
    },
    "Alt": () => {
      this.state.clickMode = "left";
    },
    "default": (e, k) => {
      if (this.state.selectedItem)
        this.state.selectedItem.keyup(e, k);
    },
    "ArrowUp": (event2) => {
      if (this.state.selectedItem) {
        this.state.releaseItem = true;
        this.onMouseUp(event2, 0, false);
      }
    },
    "ArrowDown": (event2) => {
      if (this.state.selectedItem) {
        this.state.releaseItem = true;
        this.onMouseUp(event2, 0, false);
      }
    },
    "ArrowLeft": (event2) => {
      if (this.state.selectedItem) {
        this.state.releaseItem = true;
        this.onMouseUp(event2, 0, false);
      }
    },
    "ArrowRight": (event2) => {
      if (this.state.selectedItem) {
        this.state.releaseItem = true;
        this.onMouseUp(event2, 0, false);
      }
    }
  });
  _config = {
    camera: {
      mode: "perspective",
      orthographic: {
        left: -10,
        right: 10,
        top: 16,
        bottom: -4
      },
      perspective: {
        fov: 50,
        aspect: window.innerWidth / window.innerHeight,
        near: 0.1,
        far: 1e3
      },
      minAngle: 0,
      //            maxAngle: 180,
      maxAngle: 70,
      position: {
        x: 10,
        y: 10,
        z: 10
      }
    },
    lights: {
      ambient: {
        enabled: true,
        color: 16777215,
        intensity: 0.5,
        type: "ambient"
      },
      directional: {
        enabled: false,
        color: 16711935,
        intensity: 0.9,
        type: "directional",
        position: {
          x: 10,
          y: 10,
          z: 10
        },
        target: {
          x: 0,
          y: 0,
          z: 0
        },
        castShadow: window.shadows
      },
      point: {
        enabled: true,
        color: 16777215,
        intensity: 1,
        distance: 0,
        decay: 1,
        type: "point",
        position: {
          x: 10,
          y: 10,
          z: 10
        },
        castShadow: window.shadows
      }
    },
    renderer: {
      clearColor: 16777215,
      clearAlpha: 0,
      size: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      shadows: window.shadows
    },
    floor: {
      show: true,
      width: 100,
      height: 100,
      y: -0.05,
      color: 13421772
    },
    speed: 0.5,
    grid: {
      size: 10,
      divisions: 10,
      show: true
    },
    axes: {
      size: 5,
      show: true
    },
    clickSelect: "jump"
    //"jump", // false, true, "jump"
  };
  get config() {
    return this._config;
  }
  set config(value) {
    this._config = value;
    this.configure(this._config);
  }
  updateConfig(value) {
    let o = merge(this.config, value);
    this.configure(o, o.camera.position, o.camera.lookAt ? o.camera.lookAt : { x: 0, y: 0, z: 0 });
  }
  configure(config, cameraPosition, lookAt) {
    this.configCamera(this.config.camera, cameraPosition, lookAt);
    this.configRenderer(this.config.renderer);
    this.configAxesHelper(this.config.axes);
    this.configGridHelper(this.config.grid);
    this.configFloor(this.config.floor);
    this.configLights(this.config.lights);
  }
  configRenderer(config) {
    this.renderer.setSize(config.size.width, config.size.height);
    this.renderer.setClearColor(config.clearColor, config.clearAlpha);
    this.renderer.shadowMap.enabled = config.shadows;
  }
  configCamera(config, cameraPosition, lookAt) {
    this.perspectiveCamera = new THREE.PerspectiveCamera(
      config.perspective.fov,
      config.perspective.aspect,
      config.perspective.near,
      config.perspective.far
    );
    let aspect = window.innerWidth / window.innerHeight;
    this.orthographicCamera = new THREE.OrthographicCamera(
      config.orthographic.left * aspect,
      config.orthographic.right * aspect,
      config.orthographic.top,
      config.orthographic.bottom
    );
    if (cameraPosition) {
      cameraPosition = toXYZ(cameraPosition);
    } else if (this.camera) {
      cameraPosition = this.camera.position.clone();
    }
    if (!lookAt && this.controls && this.controls.target) {
      lookAt = this.controls.target.clone();
    }
    if (this.camera && this.camera.parent)
      this.remove(this.camera);
    this.camera = config.mode === "perspective" ? this.perspectiveCamera : this.orthographicCamera;
    if (cameraPosition)
      this.camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.add(this.camera);
    this.addOrbitControls();
    if (lookAt) {
      this.controls.target.copy(lookAt);
      this.camera.lookAt(this.controls.target);
    }
  }
  addOrbitControls() {
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.minPolarAngle = this.config.camera.minAngle * Math.PI / 180;
    this.controls.maxPolarAngle = this.config.camera.maxAngle * Math.PI / 180;
    for (let [k, v] of Object.entries(this.orbitListeners)) {
      this.controls.addEventListener(k, v.bind(this));
    }
  }
  orbitListeners = {
    "start": () => {
      this.state.animate = false;
      this.state.dragging = true;
    },
    "end": () => {
      this.state.animate = true;
      this.state.dragging = false;
    }
  };
  setCameraMode(mode) {
    this.config.camera.mode = mode;
    this.configCamera(this.config.camera);
  }
  configAxesHelper(config) {
    this.axesHelper.size = config.size;
  }
  configGridHelper(config) {
    this.gridHelper.visible = config.show;
    this.gridHelper.size = config.size;
    this.gridHelper.divisions = config.divisions;
  }
  configFloor(config) {
    let floorGeometry = new THREE.PlaneGeometry(config.width, config.height, 1, 1);
    floorGeometry.rotateX(-Math.PI / 2);
    floorGeometry.translate(0, config.y, 0);
    let floorMaterial = new THREE.MeshStandardMaterial({ color: config.color });
    if (this.floor && this.floor.parent)
      this.remove(this.floor);
    this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
    this.floor.receiveShadow = true;
    this.floor.visible = config.show;
    super.add(this.floor);
  }
  configLights(config) {
    if (!this.lights) {
      this.lights = {};
    }
    for (let [lightName, spec] of Object.entries(config)) {
      let light = null;
      if (spec.enabled == false)
        continue;
      if (spec.type == "ambient") {
        light = new THREE.AmbientLight(spec.color, spec.intensity);
      } else if (spec.type == "directional") {
        light = new THREE.DirectionalLight(spec.color, spec.intensity);
        light.position.set(spec.position.x, spec.position.y, spec.position.z);
        light.target.position.set(spec.target.x, spec.target.y, spec.target.z);
        light.castShadow = spec.castShadow;
      } else if (spec.type == "point") {
        light = new THREE.PointLight(spec.color, spec.intensity, spec.distance, spec.decay);
        light.position.set(spec.position.x, spec.position.y, spec.position.z);
        light.castShadow = spec.castShadow;
      }
      if (this.lights[lightName] && this.lights[lightName].parent)
        this.remove(this.lights[lightName]);
      this.lights[lightName] = light;
      super.add(light);
    }
  }
  state = {
    dragging: false,
    animate: true,
    items: [],
    itemsByName: {},
    selectedItem: null,
    peerSelections: {},
    otherSelectedItems: {},
    selectedFace: null,
    releaseItem: true,
    moveMode: "normal",
    // "normal", "x", "y", "z", Vector3
    mouseState: null
  };
  checkIfFullyLoaded() {
    if (!this.loaded) {
      if (this.state.items.every((item) => item.loaded)) {
        this.loaded = true;
        this.loadDeferredPromise.resolve(this);
      }
    }
  }
  display(parentElement) {
    parentElement.appendChild(this.renderer.domElement);
    this.animate();
    this.sceneLoaded = true;
  }
  addModel(item, position) {
    if (item.loadPromise) {
      if (!item.loaded) {
        if (this.loaded) {
          this.loaded = false;
          this.loadDeferredPromise = new DeferredPromise();
          this.loadPromise = this.loadDeferredPromise.promise;
          this.loadPromise.then(this.loadCachedState.bind(this));
          this.loadPromise.then(() => {
            console.timeEnd("load");
          });
        }
        item.loadPromise.then(this.checkIfFullyLoaded.bind(this));
        item.loadPromise.then(() => {
          this.addModel.bind(this)(item);
        });
        this.state.itemsByName[item.name] = item;
        return;
      } else {
        this.checkIfFullyLoaded();
      }
    }
    if (item.addToScene) {
      return item.addToScene(this);
    }
    ;
    item = new MoveableItem(item);
    if (position)
      item.position.set(position.x, position.y, position.z);
    this.state.items.push(item);
    this.item = item;
    this.add(item);
  }
  reset() {
    this.state.items.map((item) => item.reset());
  }
  animate(t) {
    requestAnimationFrame(this.animate.bind(this));
    if (this.state.animate) {
      this.state.items.forEach((item) => {
        item.moveFrame(t);
      });
    }
    if (this.controls.enabled)
      this.controls.update();
    this.renderer.render(this, this.camera);
  }
  showRay(dir, origin, color = 65280, length = 10, name = "rayHelper") {
    let arrowHelper = new THREE.ArrowHelper(dir, origin, length, color);
    this.remove(this.getObjectByName(name));
    arrowHelper.name = name;
    super.add(arrowHelper);
  }
  intersectMovePlane(item) {
    let planeNormal;
    let mm = this.state.moveMode;
    if (mm === "normal") {
      planeNormal = this.camera.getWorldDirection(new THREE.Vector3()).negate();
    } else if (mm === "x") {
      planeNormal = new THREE.Vector3(1, 0, 0);
    } else if (mm === "y") {
      planeNormal = new THREE.Vector3(0, 1, 0);
    } else if (mm === "z") {
      planeNormal = new THREE.Vector3(0, 0, 1);
    } else if (mm instanceof THREE.Vector3) {
      planeNormal = mm;
    } else if (mm instanceof Array) {
      planeNormal = new THREE.Vector3(...mm);
    } else {
      planeNormal = new THREE.Vector3(mm.x, mm.y, mm.z);
    }
    let plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, item.position);
    let mouse3D = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5).unproject(this.camera);
    this.raycaster.set(this.camera.position, mouse3D.sub(this.camera.position).normalize());
    this.raycaster.ray.intersectPlane(plane, this.mouse);
  }
  getClickedItem(event2) {
    this.mouse.x = event2.clientX / window.innerWidth * 2 - 1;
    this.mouse.y = -(event2.clientY / window.innerHeight) * 2 + 1;
    this.raycaster.setFromCamera(this.mouse, this.camera);
    let items = this.state.items.map((item) => item.model).filter((v) => v);
    let intersects = this.raycaster.intersectObjects(items, true);
    if (this.state.selectedFace) {
      for (let i2 of intersects) {
        if (i2.face == this.state.selectedFace) {
          return this.state.selectedItem;
        }
      }
    }
    let o;
    let p;
    if (intersects.length) {
      o = intersects[0].object;
      this.state.selectedFace = intersects[0].face;
      p = intersects[0].point;
      while (!items.includes(o)) {
        o = o.parent;
      }
      o = o.parent.parent;
      if (!this.state.items.includes(o)) {
        console.error("clicked object not in items", o);
      }
      o.clickPoint = o.worldToLocal(p);
    } else {
      o = null;
    }
    return o;
  }
  onMouseDown(event2, button, touch) {
    if (!touch && this.config.clickSelect) {
      if (this.state.selectedItem) {
        this.state.releaseItem = true;
        this.state.dragging = true;
        return;
      } else {
        this.state.releaseItem = false;
      }
    }
    let item = this.getClickedItem(event2);
    if (item) {
      this.controls.enabled = false;
      this.state.selectedItem = item;
      this.sendItemUpdate({ "selected": item.name, nocache: true });
      this.state.dragging = true;
      this.state.mouseState = {
        original: { x: this.mouse.x, y: this.mouse.y },
        firstMove: true,
        offset: new THREE.Vector3().copy(item.position).sub(this.mouse),
        jumpOffset: new THREE.Vector3()
      };
      if (button === 2) {
        this.itemRotateClick(item);
        if (item.onRightClickDown)
          item.onRightClickDown(event2);
      } else if (button === 1) {
        if (item.onMiddleClickDown)
          item.onMiddleClickDown(event2);
      } else {
        this.itemDragClick(item);
        if (item.onMouseDown)
          item.onMouseDown(event2);
      }
    } else {
      this.state.dragging = false;
      this.state.selectedItem = null;
      this.sendItemUpdate({ "selected": null, nocache: true });
      this.state.selectedFace = null;
      this.controls.enabled = true;
    }
  }
  onMouseMove(event2, button, force = false) {
    if (!this.state.dragging) {
      return;
    }
    this.getClickedItem(event2);
    let item = this.state.selectedItem;
    if (item) {
      if (button === 2) {
        this.itemRotateMove(item);
        if (item.onRightClickMove)
          item.onRightClickMove(event2);
      } else if (button === 1) {
        if (item.onMiddleClickMove)
          item.onMiddleClickMove(event2);
      } else {
        if (event2.buttons === 1) {
          force = true;
          this.state.releaseItem = true;
        }
        this.itemDragMove(item, force);
        if (item.onMouseMove)
          item.onMouseMove(event2);
      }
    }
  }
  onMouseUp(event2, button, touch) {
    if (!button) {
      if (!this.state.releaseItem) {
        return;
      }
      if (!touch && this.config.clickSelect === "jump") {
        this.onMouseMove(event2, button, true);
      }
      ;
    }
    let item = this.state.selectedItem;
    if (item) {
      this.state.selectedItem = null;
      this.sendItemUpdate({ "unselected": item.name, nocache: true });
      this.state.selectedFace = null;
      this.state.dragging = false;
      this.addOrbitControls();
      if (button === 2) {
        this.itemRotateEnd(item);
        if (item.onRightClickUp)
          item.onRightClickUp(event2);
      } else if (button === 1) {
        if (item.onMiddleClickUp)
          item.onMiddleClickUp(event2);
      } else {
        this.itemDragEnd(item);
        if (item.onMouseUp)
          item.onMouseUp(event2);
      }
      if (item.snap) {
        item.snap();
        this.sendItemUpdate({ [item.name]: { rotation: item.pivot.rotation.toArray(), position: item.position.toArray() } });
      }
    }
  }
  onDblClick(event2) {
    let item = this.getClickedItem(event2);
    if (item) {
      item.pivot.rotateY(Math.PI / 2);
      this.sendItemUpdate({ [item.name]: { rotation: item.pivot.rotation.toArray() } });
    }
  }
  itemRotateClick(item) {
    item.pivot.originalQuaternion = item.pivot.quaternion.clone();
  }
  itemRotateMove(item) {
    let diffX = this.mouse.x - this.state.mouseState.original.x;
    let diffY = -(this.mouse.y - this.state.mouseState.original.y);
    let rotationAxis = new THREE.Vector3(diffY, diffX, 0).normalize();
    let sensitivity = 20;
    let angle = sensitivity * Math.sqrt(diffX * diffX + diffY * diffY);
    let quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle);
    let finalQuaternion = new THREE.Quaternion().multiplyQuaternions(item.pivot.originalQuaternion, quaternion);
    let euler = new THREE.Euler();
    euler.setFromQuaternion(finalQuaternion);
    if (item.snapController) {
      euler = item.snapController.enforceRotationLocks(euler);
    }
    this.sendItemUpdate({ [item.name]: { rotation: euler.toArray() }, nocache: true });
    item.pivot.rotation.set(euler.x, euler.y, euler.z);
  }
  itemRotateEnd(item) {
    if (item.snap) {
      item.snap();
      this.sendItemUpdate({ [item.name]: { rotation: item.pivot.rotation.toArray() }, nocache: true });
    }
    this.state.startPosition = null;
  }
  itemDragClick(item) {
    this.intersectMovePlane(item);
    item.startDragPosition = item.position.clone();
  }
  itemDragMove(item, force = false) {
    this.intersectMovePlane(item);
    let endPos = item.position.clone().copy(this.mouse).sub(this.state.mouseState.offset);
    endPos.y = Math.max(0, endPos.y);
    if (!this.state.mouseState.firstMove) {
      let diff = endPos.clone().sub(item.position).sub(this.state.mouseState.jumpOffset);
      if (!force && this.config.clickSelect === "jump") {
        return;
      }
      endPos = item.position.clone().add(diff);
      if (item.snapController) {
        endPos = item.snapController.enforcePositionLocks(endPos);
      }
      this.sendItemUpdate({ [item.name]: { position: endPos.toArray() }, nocache: true });
      item.position.set(endPos.x, endPos.y, endPos.z);
    } else {
      this.state.mouseState.jumpOffset = endPos.clone().sub(item.position);
      this.state.mouseState.firstMove = false;
    }
  }
  itemDragEnd(item) {
    if (item.snap) {
      try {
        item.snap();
      } catch {
        item.position.copy(item.startDragPosition);
      }
      this.sendItemUpdate({ [item.name]: { position: item.position.toArray() }, nocache: true });
    }
  }
  attachMQTTRTC(m) {
    this.m = m;
    this.m.handlers["moves"] = this.receiveItemUpdate.bind(this);
    this.syncedFrom = [];
    this.syncedTo = [];
    this.m.handlers["sync"] = this.sync.bind(this);
    /* @__PURE__ */ console.log("requesting sync");
    this.syncInterval = setInterval((() => {
      this.m.send("request", "sync");
    }).bind(this), 1e3);
    setTimeout((() => this.m.send("request", "sync")).bind(this), 100);
  }
  getFullState() {
    let data = {};
    for (let [name, item] of Object.entries(this.state.itemsByName)) {
      data[name] = { position: item.position.toArray(), rotation: item.pivot.rotation.toArray() };
    }
    return data;
  }
  cacheFullState() {
    this.fullState = this.getFullState();
    localStorage.setItem(location.hash + "FullState", JSON.stringify(this.fullState));
  }
  loadCachedState() {
    if (this.syncedFrom.length) {
      this.cacheFullState();
      return;
    }
    this.log("loading from browser cache");
    let data = JSON.parse(localStorage.getItem(location.hash + "FullState") || "false");
    if (!data) {
      return;
    }
    for (let [name, update] of Object.entries(data)) {
      let item = this.state.itemsByName[name];
      if (!item) {
        continue;
      }
      if (update.position) {
        item.position.set(...update.position);
      }
      if (update.rotation) {
        item.pivot.rotation.set(...update.rotation);
      }
    }
  }
  sync(data, sender) {
    if (data === "request") {
      if (!this.syncedFrom) {
        return;
      }
      let data2 = this.getFullState();
      this.m.send(data2, "sync", sender);
      this.syncedTo.push(sender);
      this.log(`Syncing to ${sender}`);
    } else {
      this.log(`Syncing from ${sender}`);
      this.receiveItemUpdate(data, sender, true);
      this.syncedFrom.push(sender);
      if (this.syncInterval) {
        clearInterval(this.syncInterval);
        this.syncInterval = null;
      }
    }
  }
  sendItemUpdate(data) {
    this.m.send(data, "moves");
    if (!data.nocache) {
      let changed = false;
      for (let [name, update] of Object.entries(data)) {
        if (!["selected", "unselected"].includes(name)) {
          if (!this.fullState[name]) {
            this.fullState[name] = { "position": null, "rotation": null };
          }
          changed = true;
          if (update.position) {
            this.log(`You moved ${name}`);
            this.fullState[name].position = update.position;
          }
          if (update.rotation) {
            if (!update.position)
              this.log(`You rotated ${name}`);
            this.fullState[name].rotation = update.rotation;
          }
        }
        if (changed) {
          localStorage.setItem(location.hash + "FullState", JSON.stringify(this.fullState));
        }
      }
    }
  }
  receiveItemUpdate(data, sender, forcenocache = false) {
    let cache = !(forcenocache || data.nocache);
    delete data.nocache;
    for (let [name, update] of Object.entries(data)) {
      if (name === "selected") {
        if (update) {
          if (!this.state.otherSelectedItems[update]) {
            this.state.otherSelectedItems[update] = [];
          }
          this.state.otherSelectedItems[update].push(sender);
          this.state.itemsByName[update].select(16711680);
          this.state.peerSelections[sender] = update;
        } else {
          update = this.state.peerSelections[sender];
          let selectors = this.state.otherSelectedItems[update];
          if (selectors) {
            this.state.otherSelectedItems[update] = selectors.filter((s) => s !== sender);
          }
          if (this.state.otherSelectedItems[update] && !this.state.otherSelectedItems[update].length) {
            this.state.itemsByName[update].unselect();
          }
        }
      } else if (name === "unselected") {
        let selectors = this.state.otherSelectedItems[update];
        if (selectors) {
          this.state.otherSelectedItems[update] = selectors.filter((s) => s !== sender);
        }
        if (this.state.otherSelectedItems[update] && !this.state.otherSelectedItems[update].length) {
          this.state.itemsByName[update].unselect();
        }
      } else {
        let item = this.state.itemsByName[name];
        if (!item) {
          continue;
        }
        if (update.position) {
          if (cache)
            this.log(`${sender} moved ${name}`);
          item.position.set(...update.position);
        }
        if (update.rotation) {
          if (cache && !update.position)
            this.log(`${sender} rotated ${name}`);
          item.pivot.rotation.set(...update.rotation);
        }
      }
    }
  }
  log(msg) {
    /* @__PURE__ */ console.log(msg);
    this.onlog(msg);
  }
  onlog(msg) {
  }
};

// src/js/components/base_model.js
import * as THREE3 from "three";
import { LineGeometry } from "three/addons/lines/LineGeometry.js";
import { Line2 } from "three/addons/lines/Line2.js";
import { LineMaterial } from "three/addons/lines/LineMaterial.js";

// src/js/snapControl.js
import * as THREE2 from "three";
var positions = {};
var SnapNode = class extends THREE2.Vector3 {
};
var SnapRotationNode = class extends SnapNode {
  distanceTo(node) {
    let dx = this.diffAngle(this.x, node.x);
    let dy = this.diffAngle(this.y, node.y);
    let dz = this.diffAngle(this.z, node.z);
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  diffAngle(a, b) {
    const c = Math.PI * 2;
    const p3 = 3 * Math.PI;
    a = a % c;
    b = b % c;
    let d = Math.abs((a - b + p3) % c - Math.PI);
    return d;
  }
};
var SnapNodes = class {
  constructor(nodes = [], lockedAxes = false, freeAxes = false) {
    this.nodes = nodes;
    this.getClosestNode = this.getClosestNode.bind(this);
    this._getClosestNode = this._getClosestNode.bind(this);
    if (typeof lockedAxes === "string")
      lockedAxes = { [lockedAxes]: 0 };
    this.lockedAxes = lockedAxes || {};
    freeAxes = freeAxes || [];
    if (typeof freeAxes === "string")
      freeAxes = { x: freeAxes === "x", y: freeAxes === "y", z: freeAxes === "z" };
    if (Array.isArray(freeAxes))
      freeAxes = { x: freeAxes.includes("x"), y: freeAxes.includes("y"), z: freeAxes.includes("z") };
    this.freeAxes = freeAxes;
  }
  getClosestNode(v3) {
    let node = this._getClosestNode(v3);
    this.enforceLocks(node);
    if (this.freeAxes.x)
      node.x = v3.x;
    if (this.freeAxes.y)
      node.y = v3.y;
    if (this.freeAxes.z)
      node.z = v3.z;
    return node;
  }
  sortNodesByDistance(v3) {
    let nodesWithDistances = this.nodes.map((n) => {
      return {
        node: n,
        distance: n.distanceTo(v3)
      };
    });
    nodesWithDistances.sort((a, b) => a.distance - b.distance);
    let sortedNodes = nodesWithDistances.map((n) => n.node);
    return sortedNodes;
  }
  _getClosestNode(v3) {
    let sortedNodes = this.sortNodesByDistance(v3);
    return sortedNodes[0];
  }
  enforceLocks(v3) {
    if (this.lockedAxes.x !== void 0)
      v3.x = this.lockedAxes.x;
    if (this.lockedAxes.y !== void 0)
      v3.y = this.lockedAxes.y;
    if (this.lockedAxes.z !== void 0)
      v3.z = this.lockedAxes.z;
    return v3;
  }
};
var PositionSnapNodes = class extends SnapNodes {
};
var RotationSnapNodes = class extends SnapNodes {
};
var CubeRotationNodes = class extends RotationSnapNodes {
  constructor(lockedAxes = false, freeAxes = false) {
    super([
      new SnapRotationNode(0, 0, 0),
      new SnapRotationNode(Math.PI / 2, 0, 0),
      new SnapRotationNode(Math.PI, 0, 0),
      new SnapRotationNode(Math.PI * 1.5, 0, 0),
      new SnapRotationNode(Math.PI * 2, 0, 0),
      new SnapRotationNode(0, Math.PI / 2, 0),
      new SnapRotationNode(0, Math.PI, 0),
      new SnapRotationNode(0, Math.PI * 1.5, 0),
      new SnapRotationNode(0, Math.PI * 2, 0),
      new SnapRotationNode(0, 0, Math.PI / 2),
      new SnapRotationNode(0, 0, Math.PI),
      new SnapRotationNode(0, 0, Math.PI * 1.5),
      new SnapRotationNode(0, 0, Math.PI * 2)
    ], lockedAxes, freeAxes);
  }
  getClosestRotation(v3) {
    let node = this._getClosestRotation(v3);
    if (this.lockedAxes.x !== void 0)
      node.x = v3.x;
    if (this.lockedAxes.y !== void 0)
      node.y = v3.y;
    if (this.lockedAxes.z !== void 0)
      node.z = v3.z;
    if (this.freeAxes.x)
      node.x = v3.x;
    if (this.freeAxes.y)
      node.y = v3.y;
    if (this.freeAxes.z)
      node.z = v3.z;
    return node;
  }
  _getClosestRotation(v3) {
    let step = Math.PI / 2;
    let x = Math.round(v3.x / step) * step;
    let y = Math.round(v3.y / step) * step;
    let z = Math.round(v3.z / step) * step;
    return new SnapRotationNode(x, y, z);
  }
};
var GridRotationNodes = class extends RotationSnapNodes {
  constructor(lockedAxes = false, freeAxes = false) {
    super([
      new SnapRotationNode(0, Math.PI / 2, 0),
      new SnapRotationNode(0, Math.PI, 0),
      new SnapRotationNode(0, Math.PI * 1.5, 0),
      new SnapRotationNode(0, Math.PI * 2, 0)
    ], lockedAxes, freeAxes);
  }
  getClosestRotation(v3) {
    let node = this._getClosestRotation(v3);
    if (this.lockedAxes.x !== void 0)
      node.x = v3.x;
    if (this.lockedAxes.y !== void 0)
      node.y = v3.y;
    if (this.lockedAxes.z !== void 0)
      node.z = v3.z;
    if (this.freeAxes.x)
      node.x = v3.x;
    if (this.freeAxes.y)
      node.y = v3.y;
    if (this.freeAxes.z)
      node.z = v3.z;
    return node;
  }
  _getClosestRotation(v3) {
    let step = Math.PI / 2;
    let x = Math.round(v3.x / step) * step;
    let y = Math.round(v3.y / step) * step;
    let z = Math.round(v3.z / step) * step;
    return new SnapRotationNode(x, y, z);
  }
};
var LatticeNodes = class extends PositionSnapNodes {
  constructor(step = 1, offset = 0, lockedAxes = false, freeAxes = false) {
    super([], lockedAxes, freeAxes);
    this.step = typeof step === "number" ? new THREE2.Vector3(step, step, step) : step;
    this.offset = typeof offset === "number" ? new THREE2.Vector3(offset, offset, offset) : offset;
  }
  _getClosestNode(v3) {
    let x = Math.round((v3.x - this.offset.x) / this.step.x) * this.step.x + this.offset.x;
    let y = Math.round((v3.y - this.offset.y) / this.step.y) * this.step.y + this.offset.y;
    let z = Math.round((v3.z - this.offset.z) / this.step.z) * this.step.z + this.offset.z;
    return new SnapNode(x, y, z);
  }
};
var GridNodes = class extends LatticeNodes {
  constructor(step = 1, offset = 0, lockedAxes = "y", freeAxes = false) {
    super(step, offset, lockedAxes, freeAxes);
  }
};
var SnapController = class {
  constructor(item, y = 0, step = 1, offset = 0, lockedAxes = "default", freeAxes = false, rotationLockedAxes = false, rotationFreeAxes = false, positionNodes = "grid", rotationNodes = "cube") {
    this.item = item;
    this.snap = this.snap.bind(this);
    this.enforceRotationLocks = this.enforceRotationLocks.bind(this);
    this.enforcePositionLocks = this.enforcePositionLocks.bind(this);
    this.snapRotation = this.snapRotation.bind(this);
    this.snapPosition = this.snapPosition.bind(this);
    this.getClosestRotation = this.getClosestRotation.bind(this);
    this.getClosestPosition = this.getClosestPosition.bind(this);
    if (rotationLockedAxes) {
      if (typeof rotationLockedAxes === "string")
        rotationLockedAxes = { [rotationLockedAxes]: true };
      if (Array.isArray(rotationLockedAxes))
        rotationLockedAxes = rotationLockedAxes.reduce((obj, axis) => {
          obj[axis] = true;
          return obj;
        }, {});
      for (let axis in rotationLockedAxes) {
        if (rotationLockedAxes[axis] === true)
          rotationLockedAxes[axis] = item.pivot.rotation[axis];
      }
    }
    if (lockedAxes) {
      if (lockedAxes === "default")
        lockedAxes = { y };
      if (typeof lockedAxes === "string")
        lockedAxes = { [lockedAxes]: true };
      if (Array.isArray(lockedAxes))
        lockedAxes = lockedAxes.reduce((obj, axis) => {
          obj[axis] = true;
          return obj;
        }, {});
      for (let axis in lockedAxes) {
        if (lockedAxes[axis] === true)
          lockedAxes[axis] = item.pivot.position[axis];
      }
    }
    if (positionNodes === "grid")
      positionNodes = new GridNodes(step, offset, lockedAxes === "default" ? { y } : lockedAxes, freeAxes);
    if (positionNodes === "lattice")
      positionNodes = new LatticeNodes(step, offset, lockedAxes, freeAxes);
    if (rotationNodes === "cube")
      rotationNodes = new CubeRotationNodes(rotationLockedAxes, rotationFreeAxes);
    if (rotationNodes === "grid")
      rotationNodes = new GridRotationNodes(rotationLockedAxes, rotationFreeAxes);
    if (rotationNodes === "up")
      rotationNodes = new SnapNodes([new SnapRotationNode(0, 0, 0)], rotationLockedAxes, rotationFreeAxes);
    if (rotationNodes === "flip")
      rotationNodes = new SnapNodes([new SnapRotationNode(0, 0, 0), new SnapRotationNode(0, Math.PI, 0)], rotationLockedAxes, rotationFreeAxes);
    this.rotationNodes = rotationNodes;
    this.positionNodes = positionNodes;
  }
  config = {
    enabled: true,
    rotation: {
      enabled: true,
      step: Math.PI / 2
    },
    position: {
      enabled: true,
      step: 1
    }
  };
  setNodes(positionNodes, rotationNodes) {
    this.rotationNodes = rotationNodes;
    this.positionNodes = positionNodes;
  }
  snap() {
    if (!this.config.enabled)
      return;
    if (this.config.rotation.enabled)
      this.snapRotation();
    if (this.config.position.enabled)
      this.snapPosition();
  }
  snapPosition() {
    let p = this.item.position;
    let closest = this.getClosestPosition(p);
    this.item.position.set(closest.x, closest.y, closest.z);
  }
  getClosestPosition(p) {
    let newP = this.positionNodes.getClosestNode(p);
    if (this.checkCollision(newP))
      throw new Error("collision");
    return newP;
  }
  getClosestRotation(r) {
    return this.rotationNodes.getClosestNode(r);
  }
  snapRotation() {
    let r = this.item.pivot.rotation;
    let closest = this.getClosestRotation(r);
    r.set(closest.x, closest.y, closest.z);
  }
  enforceRotationLocks(newRotation) {
    return this.rotationNodes.enforceLocks(newRotation);
  }
  enforcePositionLocks(newPosition) {
    return this.positionNodes.enforceLocks(newPosition);
  }
  checkCollision(newP) {
    let s = `${newP.x}, ${newP.y}, ${newP.z}`;
    if (positions[s] && positions[s] !== this.item)
      return true;
    if (positions[this.item.lastPositionString]) {
      delete positions[this.item.lastPositionString];
    }
    positions[s] = this.item;
    this.item.lastPositionString = s;
    return false;
  }
};

// src/js/components/base_model.js
var BaseModel = class extends THREE3.Group {
  constructor(loadPromise) {
    super();
    this.truePivot = new THREE3.Object3D();
    this.pivot = this.truePivot;
    this.pivot.position.copy(this.position);
    this.castShadow = this.config.castShadow;
    this.receiveShadow = this.config.receiveShadow;
    this.loadPromise = loadPromise;
    this.loaded = false;
    this.wireframe = null;
    this.originCube = null;
    this.cube = new THREE3.Mesh(new THREE3.BoxGeometry(1, 1, 1), new THREE3.MeshBasicMaterial({ color: 16777215 }));
    this.truePivot.add(this.cube);
    this.loadPromise.then(((model) => {
      if (typeof model === "object" && model.config && model.model) {
        this.config = model.config;
        this.position.set(model.position.x, model.position.y, model.position.z);
        this.rotation.set(model.rotation.x, model.rotation.y, model.rotation.z);
        this.truePivot.position.set(model.pivotPosition.x, model.pivotPosition.y, model.pivotPosition.z);
        this.truePivot.rotation.set(model.pivotRotation.x, model.pivotRotation.y, model.pivotRotation.z);
        let loader = new THREE3.ObjectLoader();
        model = loader.parse(model.model);
        this.model = model;
        this.add(model);
        this.truePivot.add(this.model);
        this.add(this.truePivot);
        this.addOriginCube();
        this.addWireframe();
        this.truePivot.add(this.wireframe);
        this.truePivot.add(this.originCube);
        this.snapController = new SnapController(this);
        this.setShadow(this.config.castShadow, this.config.receiveShadow);
      } else {
        this.model = model;
        model.castShadow = this.config.castShadow;
        model.receiveShadow = this.config.receiveShadow;
        this.add(model);
        let box = this.getBoundingBox();
        let size = this.getSize();
        let center = box.getCenter(new THREE3.Vector3());
        this.truePivot.add(this.model);
        this.add(this.truePivot);
        this.truePivot.position.set(size.x / 2, 0, size.z / 2);
        this.addOriginCube();
        this.addWireframe();
        this.truePivot.add(this.wireframe);
        this.truePivot.add(this.originCube);
        this.snapController = new SnapController(this);
        this.setShadow(this.config.castShadow, this.config.receiveShadow);
      }
      this.loaded = true;
      this.remove(this.cube);
      this.truePivot.remove(this.cube);
      delete this.cube;
    }).bind(this));
  }
  keydown(event2, k) {
    if (this.keydownListeners[k]) {
      this.keydownListeners[k](event2);
    }
  }
  keyup(event2, k) {
    if (this.keyupListeners[k]) {
      this.keyupListeners[k](event2);
    }
  }
  keydownListeners = {
    "ArrowRight": (event2) => {
      this.pivot.rotateY(Math.PI / 2);
    },
    "ArrowLeft": (event2) => {
      this.pivot.rotateY(-Math.PI / 2);
    }
  };
  keyupListeners = {};
  toJSON() {
    return {
      isModelCopy: true,
      position: this.position,
      rotation: this.rotation,
      config: this.config,
      model: this.model.toJSON(),
      pivotPosition: this.truePivot.position,
      pivotRotation: this.truePivot.rotation
    };
  }
  setSnapNodes(nodes) {
    if (!this.model) {
      return this.loadPromise.then(this.setSnapNodes.bind(this, nodes));
    }
    this.snapController.positionNodes = nodes;
  }
  setSnapController(...args) {
    if (!this.model) {
      return this.loadPromise.then(this.setSnapController.bind(this, ...args));
    }
    this.snapController = new SnapController(this, ...args);
  }
  setShadow(cast = true, receive = true) {
    this.castShadow = cast;
    this.receiveShadow = receive;
    if (!this.model) {
      return this.loadPromise.then(this.setShadow.bind(this, cast, receive));
    }
    if (this.model) {
      this.model.castShadow = cast;
      this.model.receiveShadow = receive;
      for (let child of this.model.children) {
        child.castShadow = cast;
        child.receiveShadow = receive;
      }
    }
  }
  snap() {
    if (!this.model) {
      return this.loadPromise.then(this.snap.bind(this));
    }
    if (this.config.snap && this.snapController) {
      this.snapController.snap();
    }
  }
  config = {
    snap: true,
    castShadow: true,
    receiveShadow: true,
    wireframe: {
      visible: false,
      color: 65280,
      thickness: 2
    },
    originCube: {
      visible: false,
      color: 65535,
      thickness: 0.2
    },
    selected: {
      scale: 1.05,
      wireframe: true,
      originCube: true,
      offset: new THREE3.Vector3(0, 0.5, 0)
    }
  };
  getBoundingBox() {
    var box = new THREE3.Box3();
    this.traverse(function(child) {
      if (child.isMesh) {
        child.geometry.computeBoundingBox();
        var childBox = child.geometry.boundingBox.clone();
        childBox.applyMatrix4(child.matrixWorld);
        box.union(childBox);
      }
    });
    box.min.add(this.model.position);
    box.max.add(this.model.position);
    return box;
  }
  getSize() {
    let size = new THREE3.Vector3();
    let box = this.getBoundingBox();
    box.getSize(size);
    return size;
  }
  getRepresentativeSize() {
    let size = this.getSize();
    let sizes = [size.x, size.y, size.z];
    sizes.sort();
    let avgSize = (sizes[0] + sizes[1]) / 2;
    return avgSize;
  }
  addOriginCube() {
    let s = this.getRepresentativeSize();
    let t = this.config.originCube.thickness;
    const geometry = new THREE3.BoxGeometry(s * t, s * t, s * t);
    const material = new THREE3.MeshBasicMaterial({ color: this.config.originCube.color });
    const cube = new THREE3.Mesh(geometry, material);
    cube.visible = this.config.originCube.visible;
    this.originCube = cube;
  }
  addWireframe() {
    let boundingBox = this.getBoundingBox();
    let boxGeometry = new THREE3.BoxGeometry(
      boundingBox.max.x - boundingBox.min.x,
      boundingBox.max.y - boundingBox.min.y,
      boundingBox.max.z - boundingBox.min.z
    );
    boxGeometry.translate(
      (boundingBox.min.x + boundingBox.max.x) / 2,
      (boundingBox.min.y + boundingBox.max.y) / 2,
      (boundingBox.min.z + boundingBox.max.z) / 2
    );
    let edges = new THREE3.EdgesGeometry(boxGeometry);
    let geometry = new LineGeometry();
    geometry.setPositions(edges.attributes.position.array);
    let avgSize = this.getRepresentativeSize();
    let s = avgSize * this.config.wireframe.thickness;
    let material = new LineMaterial({
      color: this.config.wireframe.color,
      linewidth: s
      // Set the line width here
    });
    let wireframeMesh = new Line2(geometry, material);
    material.resolution.set(window.innerWidth, window.innerHeight);
    wireframeMesh.visible = this.config.wireframe.visible;
    this.wireframe = wireframeMesh;
  }
  setColor(color) {
    if (!this.model) {
      this.cube.material.color.set(color);
      return this.loadPromise.then(() => {
        this.setColor(color);
      });
    }
    ;
    this.model.traverse((child) => {
      if (child instanceof THREE3.Mesh) {
        if (Array.isArray(child.material)) {
          child.material.forEach((material) => {
            material.color.set(color);
          });
        } else {
          child.material.color.set(color);
        }
      }
    });
  }
  setPosition(p) {
    if (!this.model) {
      this.cube.position.set(p.x, p.y, p.z);
      return this.loadPromise.then(() => {
        this.setPosition(p);
      });
    }
    ;
    this.model.position.set(p.x, p.y, p.z);
  }
  rotate(rx = 0, ry = 0, rz = 0) {
    this.pivot.rotation.x += rx;
    this.pivot.rotation.y += ry;
    this.pivot.rotation.z += rz;
  }
  onMouseDown(event2) {
    let m = this.config.selected.scale;
    this.scale.set(m, m, m);
    if (!this.offset) {
      this.offset = true;
      this.model.position.add(this.config.selected.offset);
      this.wireframe.position.add(this.config.selected.offset);
      this.originCube.position.add(this.config.selected.offset);
    }
    this.wireframe.visible = this.config.selected.wireframe;
    this.originCube.visible = this.config.selected.originCube;
  }
  onMouseUp(event2) {
    this.scale.set(1, 1, 1);
    if (this.offset) {
      this.offset = false;
      this.model.position.sub(this.config.selected.offset);
      this.wireframe.position.sub(this.config.selected.offset);
      this.originCube.position.sub(this.config.selected.offset);
    }
    this.wireframe.visible = false;
    this.originCube.visible = false;
  }
  onRightClickDown(event2) {
    this.onMouseDown(event2);
  }
  onRightClickMove(event2) {
  }
  onRightClickUp(event2) {
    this.onMouseUp(event2);
  }
  select(color) {
    if (color !== void 0) {
      this.wireframe.material.color.set(color);
    }
    this.wireframe.visible = true;
  }
  unselect() {
    this.wireframe.visible = false;
    this.wireframe.material.color.set(this.config.wireframe.color);
  }
};

// src/js/components/cube.js
import * as THREE4 from "three";
function getMaterial(v, loader) {
  let loadPromise = false;
  if (v instanceof THREE4.MeshStandardMaterial) {
  } else if (v instanceof THREE4.Texture) {
    v = new THREE4.MeshStandardMaterial({ map: v });
  } else if (v instanceof THREE4.Color) {
    v = new THREE4.MeshStandardMaterial({ color: v });
  } else if (typeof v === "string") {
    if (v.includes(".") || v.includes("/") || v.includes("\\")) {
      let deferredLoadPromise = new DeferredPromise();
      v = new THREE4.MeshStandardMaterial({
        map: loader.load(v, deferredLoadPromise.resolve, void 0, deferredLoadPromise.reject)
      });
      loadPromise = deferredLoadPromise.promise;
    } else {
      v = new THREE4.MeshStandardMaterial({ color: new THREE4.Color(v) });
    }
  }
  v.castShadow = true;
  v.receiveShadow = true;
  return [v, loadPromise];
}
function underside(material) {
  let m = material.clone();
  m.flipY = true;
  return m;
}
function loadCube(sources) {
  sources = sources || {};
  if (typeof sources === "string") {
    sources = { front: sources };
  }
  let minDimension = sources.minDimension || 0.01;
  let defaultColors = sources.colors || {
    front: "gray",
    back: "gray",
    left: "gray",
    right: "gray",
    top: "white",
    bottom: "gray"
  };
  let dimensions = sources.dimensions || {};
  let loader = new THREE4.TextureLoader();
  let dimensionNames = ["width", "height", "depth"];
  let pairs = [["front", "back"], ["left", "right"], ["top", "bottom"]];
  dimensions = {
    width: {
      input: dimensions.width,
      top: null,
      bottom: null,
      front: null,
      back: null
    },
    height: {
      input: dimensions.height,
      front: null,
      back: null,
      left: null,
      right: null
    },
    depth: {
      input: dimensions.depth,
      top: null,
      bottom: null,
      left: null,
      right: null
    }
  };
  let materials = Object.assign({
    front: null,
    back: null,
    left: null,
    right: null,
    top: null,
    bottom: null
  }, sources);
  let promises = [];
  let promise = new DeferredPromise();
  for (let [k, v] of Object.entries(materials)) {
    if (v) {
      let [mat, loadPromise] = getMaterial(v, loader);
      materials[k] = mat;
      if (loadPromise) {
        promises.push(loadPromise);
        loadPromise.then((texture) => {
          if (["top", "bottom"].includes(k)) {
            dimensions.width[k] = texture.image.naturalWidth;
            dimensions.depth[k] = texture.image.naturalHeight;
          } else if (["front", "back"].includes(k)) {
            dimensions.width[k] = texture.image.naturalWidth;
            dimensions.height[k] = texture.image.naturalHeight;
          } else if (["left", "right"].includes(k)) {
            dimensions.depth[k] = texture.image.naturalWidth;
            dimensions.height[k] = texture.image.naturalHeight;
          }
        });
      }
    }
  }
  Promise.all(promises).then(() => {
    let avgDimensions = {};
    for (let [k, v] of Object.entries(dimensions)) {
      let sum = 0;
      let count = 0;
      for (let [k2, v2] of Object.entries(v)) {
        if (k2 !== "input" && v2) {
          sum += v2;
          count += 1;
        }
      }
      avgDimensions[k] = sum ? sum / count : 0;
      ;
    }
    let meanDimension = (avgDimensions.width + avgDimensions.height + avgDimensions.depth) / 3;
    avgDimensions = {
      width: avgDimensions.width / meanDimension,
      height: avgDimensions.height / meanDimension,
      depth: avgDimensions.depth / meanDimension
    };
    let numDimensionInputs = dimensionNames.filter((k) => dimensions[k].input != null).length;
    if (numDimensionInputs === 0) {
      dimensions = avgDimensions;
    } else if (numDimensionInputs === 1) {
      let k = dimensionNames.find((k2) => dimensions[k2].input != null);
      let scale = dimensions[k].input / avgDimensions[k];
      dimensions = {
        width: avgDimensions.width * scale,
        height: avgDimensions.height * scale,
        depth: avgDimensions.depth * scale
      };
    } else if (numDimensionInputs === 2) {
      let missingDimension = dimensionNames.find((k) => dimensions[k].input == null);
      let avgDim = avgDimensions[missingDimension];
      let val = 0;
      for (let k of dimensionNames) {
        if (k !== missingDimension && avgDimensions[k]) {
          val += avgDim * avgDimensions[k] / dimensions[k].input;
        }
      }
      val /= 2;
      dimensions = {
        width: dimensions.width.input,
        height: dimensions.height.input,
        depth: dimensions.depth.input
      };
      dimensions[missingDimension] = val;
    } else {
      dimensions = {
        width: dimensions.width.input,
        height: dimensions.height.input,
        depth: dimensions.depth.input
      };
    }
    for (let [a, b] of pairs) {
      if (materials[a] && materials[b]) {
      } else if (materials[a]) {
        materials[b] = underside(materials[a]);
      } else if (materials[b]) {
        materials[a] = underside(materials[b]);
      } else {
        materials[a] = new THREE4.MeshStandardMaterial({ color: defaultColors[a] });
        materials[b] = new THREE4.MeshStandardMaterial({ color: defaultColors[b] });
      }
    }
    let sizes = [dimensions.width, dimensions.height, dimensions.depth];
    sizes.sort();
    let avgSide = (sizes[0] + sizes[1]) / 2;
    let minSide = minDimension * avgSide;
    dimensions = {
      width: dimensions.width || minSide,
      height: dimensions.height || minSide,
      depth: dimensions.depth || minSide
    };
    let geometry = new THREE4.BoxGeometry(dimensions.width, dimensions.height, dimensions.depth);
    const cube = new THREE4.Mesh(geometry, [
      materials.right,
      materials.left,
      materials.top,
      materials.bottom,
      materials.front,
      materials.back
    ]);
    cube.position.set(0, dimensions.height / 2, 0);
    promise.resolve(cube);
  });
  return promise.promise;
}
function loadCylinder(sources, minDimension = 0.1) {
  let loader = new THREE4.TextureLoader();
  let materials = Object.assign({
    top: "white",
    bottom: "black",
    side: "gray"
  }, sources);
  let promises = [];
  let promise = new DeferredPromise();
  for (let [k, v] of Object.entries(materials)) {
    let [mat, loadPromise] = getMaterial(materials[k], loader);
    materials[k] = mat;
    promises.push(loadPromise);
  }
  Promise.all(promises).then(() => {
    let radius = sources.dimensions.radius || 1;
    let height = sources.dimensions.height || 1;
    let segments = 32;
    let sideGeometry = new THREE4.CylinderGeometry(radius, radius, height, 32);
    let sideMesh = new THREE4.Mesh(sideGeometry, [materials.side, materials.top, materials.bottom]);
    sideMesh.position.set(-radius, height / 2, -radius);
    promise.resolve(sideMesh);
  });
  return promise.promise;
}

// src/js/components/3d_model.js
import * as THREE5 from "three";
import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
import { STLLoader as STLLoader2 } from "three/addons/loaders/STLLoader.js";
import { GLTFLoader as GLTFLoader2 } from "three/addons/loaders/GLTFLoader.js";

// src/js/utils/db.js
var IndexedDBBackend = class {
  constructor(dbName = "myDatabase", storeName = "myStore") {
    this.dbName = dbName;
    this.storeName = storeName;
    this.db = null;
    let deferredPromise = new DeferredPromise();
    this.loadPromise = deferredPromise.promise;
    this.loaded = false;
    const request = indexedDB.open(this.dbName, 1);
    request.onerror = (event2) => {
      console.error("Database error:", event2.target.error);
      deferredPromise.reject(event2.target.error);
    };
    request.onupgradeneeded = (event2) => {
      this.db = event2.target.result;
      if (!this.db.objectStoreNames.contains(this.storeName)) {
        this.db.createObjectStore(this.storeName);
      }
    };
    request.onsuccess = (event2) => {
      this.db = event2.target.result;
      this.loaded = true;
      deferredPromise.resolve(this.db);
    };
  }
  _getStore(transactionMode) {
    return this.db.transaction([this.storeName], transactionMode).objectStore(this.storeName);
  }
  async setItem(key, value) {
    if (!this.loaded) {
      await this.loadPromise;
    }
    return new Promise((resolve, reject) => {
      const store = this._getStore("readwrite");
      const request = store.put(value, key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  async getItem(key) {
    if (!this.loaded) {
      await this.loadPromise;
    }
    return new Promise((resolve, reject) => {
      const store = this._getStore("readonly");
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async deleteItem(key) {
    if (!this.loaded) {
      await this.loadPromise;
    }
    return new Promise((resolve, reject) => {
      const store = this._getStore("readwrite");
      const request = store.delete(key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
};

// src/js/components/3d_model.js
var loadPaths = {};
var objectLoader = new THREE5.ObjectLoader();
var db = new IndexedDBBackend();
window.db = db;
window.loadPaths = loadPaths;
var i = 0;
function load3DModel(path) {
  var loader;
  let fileType = path.toLowerCase().split(".").pop();
  let promise = new DeferredPromise();
  i += 1;
  let name = path + "-" + i;
  promise.promise.then((model) => {
    model.name = path;
    console.timeEnd(name);
  });
  let o = loadPaths[path];
  if (o) {
    if (o instanceof Promise) {
      console.time(name);
      o.then((j) => {
        const obj = objectLoader.parse(j);
        promise.resolve(obj);
      });
    } else {
      console.time(name);
      const obj = objectLoader.parse(o);
      promise.resolve(obj);
      return promise.promise;
    }
  } else {
    let jsonPromise = new DeferredPromise();
    loadPaths[path] = jsonPromise.promise;
    db.getItem(path).then((o2) => {
      if (o2) {
        jsonPromise.resolve(o2);
        loadPaths[path] = o2;
        const obj = objectLoader.parse(o2);
        promise.resolve(obj);
        return;
      }
      promise.promise.then((object) => {
        o2 = object.toJSON();
        jsonPromise.resolve(o2);
        loadPaths[path] = o2;
        db.setItem(path, o2);
      });
      loadFile(promise, path, fileType);
    });
  }
  return promise.promise;
}
function loadFile(promise, path, fileType) {
  let loader;
  switch (fileType.toLowerCase()) {
    case "gltf":
      loader = new THREE5.GLTFLoader();
      loader.load(path, function(gltf) {
        promise.resolve(gltf.scene);
      });
      break;
    case "obj":
      loader = new OBJLoader();
      loader.load(path, function(object) {
        promise.resolve(object);
      });
      break;
    case "stl":
      loader = new THREE5.STLLoader();
      loader.load(path, function(geometry) {
        let material = new THREE5.MeshPhongMaterial({ color: 16733491, specular: 1118481, shininess: 200 });
        var mesh = new THREE5.Mesh(geometry, material);
        promise.resolve(mesh);
      });
      break;
    default:
      promise.reject("Unsupported file type:" + fileType);
      return;
  }
}

// src/js/components/text.js
import * as THREE6 from "three";
var knownFonts = {
  gentilis_bold: "https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/fonts/gentilis_bold.typeface.json",
  gentilis_regular: "https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/fonts/gentilis_regular.typeface.json",
  helvetiker_bold: "https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/fonts/helvetiker_bold.typeface.json",
  helvetiker_regular: "https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/fonts/helvetiker_regular.typeface.json",
  optimer_bold: "https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/fonts/optimer_bold.typeface.json"
};
function makeText(text, size = 1, color = 0, height = 0.1, fontPath = "helvetiker_regular", curveSegments = 12, bevelEnabled = false, rotation = { x: -Math.PI / 2, y: 0, z: 0 }) {
  if (knownFonts[fontPath]) {
    fontPath = knownFonts[fontPath];
  }
  let loader = new THREE6.FontLoader();
  let promise = new DeferredPromise();
  if (!fontPath) {
    console.error("Font is not provided. Please load a font and pass it to the SimpleText constructor.");
    return;
  }
  loader.load(fontPath, function(font) {
    const textGeometry = new THREE6.TextGeometry(text, { font, size, height, curveSegments, bevelEnabled });
    const textMaterial = new THREE6.MeshBasicMaterial({ color });
    let mesh = new THREE6.Mesh(textGeometry, textMaterial);
    mesh.rotation.set(rotation.x, rotation.y, rotation.z);
    let g = new THREE6.Group();
    g.add(mesh);
    promise.resolve(g);
  });
  return promise.promise;
}
function loadText(config) {
  if (typeof config === "string")
    config = { text: config };
  return makeText(config.text, config.size, config.color, config.height, config.fontPath, config.curveSegments, config.bevelEnabled);
}

// src/js/components/model.js
function loadModel(source) {
  if (typeof source === "string" && source.startsWith("{") && source.endsWith("}")) {
    source = JSON.parse(source);
  }
  if (source.isModelCopy) {
    return Promise.resolve(source);
  }
  if (typeof source === "object" && !source.text || typeof source === "string" && source.toLowerCase().endsWith(".png")) {
    if (source.dimensions && source.dimensions.radius) {
      return loadCylinder(source);
    }
    return loadCube(source);
  } else if (typeof source === "string" && source.endsWith(".json") || typeof source === "object" && source.text) {
    return loadText(source);
  } else {
    return load3DModel(source);
  }
}
var Model = class extends BaseModel {
  constructor({ src, color, name, position, rotation, moveable, metadata }) {
    if (src instanceof Promise) {
      super(src);
    } else {
      super(loadModel(src));
    }
    if (color !== void 0)
      this.setColor(color);
    if (name)
      this.name = name;
    if (position)
      this.position.set(position.x, position.y, position.z);
    if (rotation)
      this.pivot.rotation.set(rotation.x, rotation.y, rotation.z);
    if (metadata)
      this.metadata = metadata;
    if (moveable)
      this.moveable = moveable;
  }
};
function loadJSON(scene, src) {
  let folder = src.substring(0, src.lastIndexOf("/") + 1);
  return fetch(src).then((r) => r.json()).then((json) => {
    let metadata = json.metadata || {};
    if (json.metadata) {
      delete json.metadata;
    }
    let snaps = json.snaps;
    delete json.snaps;
    let sceneSpec = json.scene;
    delete json.scene;
    if (sceneSpec) {
      scene.updateConfig(sceneSpec);
    }
    let models = {};
    for (let [name, details] of Object.entries(json)) {
      details.name = name;
      if (typeof details.src === "string") {
        details.src = details.src.replaceAll("GAME/", folder);
      } else {
        details.src = JSON.parse(JSON.stringify(details.src).replaceAll("GAME/", folder));
      }
      let model = new Model(details);
      models[name] = model;
      if (details.moveable) {
        scene.addModel(model);
      } else {
        scene.add(model);
      }
    }
    scene.loadPromise.then(() => {
      for (let [name, details] of Object.entries(json)) {
        let model = models[name];
        if (details.snap) {
          let s = snaps[details.snap];
          model.setSnapController(s.y, s.step, s.offset, s.lockedAxes, s.freeAxes, s.rotationLockedAxes, s.rotationFreeAxes, s.positionNodes, s.rotationNodes);
          model.snap();
        } else if (details.snap === false) {
          model.snapController = null;
        }
        if (details.animation) {
          if (details.animation.rotation) {
            let r = details.animation.rotation;
            model.startRotation(r.x, r.y, r.z);
          }
          if (details.animation.position) {
            let p = details.animation.position;
            model.startTranslation(p.x, p.y, p.z);
          }
        }
      }
    });
    return { models, metadata };
  });
}

// src/js/gameboard.js?v20230820T20:59:36.359Z
var GameBoard = class extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    const styleLink = document.createElement("link");
    styleLink.setAttribute("rel", "stylesheet");
    styleLink.setAttribute("href", "./src/css/style.css");
    this.shadowRoot.appendChild(styleLink);
    const wrapper = document.createElement("div");
    wrapper.innerHTML = `
          <div id="sceneBox" class="sceneBox"></div>
          <div id="select" class="widget tl">
            <select id="gameSelect">
                <option value="lobby">Please select a game</option>
            </select><br/>
            <select id="roomSelect">
                <option value="lobby">Please select a room</option>
            </select><br/>
            <input id="roomInput" placeholder="Room Name" class="hidden"></input>
          </div>
          <div id="instructionsBox" class="widget tr">
                <button id="q">?</button>
                <button id = "x" class="fr hidden">x</button>
                <pre id="instructions" class="hidden">
                </pre>
          </div>
          <pre id="subtitles" class="widget bc subtitles"></pre>
          <div id="disappearingLog" class="floating bl">

          </div>
          <button id="hideLogs" class="widget logs" style="opacity: 0;">x</button>
          <button id="showLogs" class="widget logs hidden">+</button>
          <chat-box id="chat" class="widget"></chat-box>

        `;
    wrapper.classList.add("fullscreen");
    this.shadowRoot.appendChild(wrapper);
    this.gameNames = ["lobby", "quoridor", "chess", "card", "cube"];
    this.roomNames = ["lobby", "octopus", "snail", "tree", "tortoise", "anchovie", "punctuation", "kettle", "circular", "squirrel", "caterpillar", "cucumber", "lightbulb", "snorkel", "giraffe", "chocolate"];
    this.secretRooms = JSON.parse(localStorage.getItem("secretRooms") || "[]");
    this.roomNames = this.roomNames.concat(this.secretRooms);
    this.roomNames.push("+");
    for (let o of [this.handlers, this.keydownHandlers, this.keyupHandlers]) {
      for (let [k, v] of Object.entries(o)) {
        o[k] = v.bind(this);
      }
    }
    this.onDocumentLoad = this.onDocumentLoad.bind(this);
    this.saveElements = this.saveElements.bind(this);
    this.bindElements = this.bindElements.bind(this);
    this.loadGame = this.loadGame.bind(this);
    this.showInstructions = this.showInstructions.bind(this);
    this.hideInstructions = this.hideInstructions.bind(this);
    this.rtc = new MQTTRTCClient({ handlers: this.handlers });
    this.voiceChat = new WebRTCAudioChannel(this.rtc);
    this.keyListeners = new KeyListeners(this.keydownHandlers, this.keyupHandlers);
    this.keyListeners.addTo(window);
    this.scene = new CustomScene();
    this.scene.onlog = this.log.bind(this);
    this.scene.attachMQTTRTC(this.rtc);
    /* @__PURE__ */ console.log("Gameboard constructed");
    this.onDocumentLoad();
  }
  onDocumentLoad() {
    /* @__PURE__ */ console.log("document loaded");
    window.g = this;
    this.saveElements();
    this.bindElements();
    this.loadGame();
  }
  saveElements() {
    this.instructions = this.shadowRoot.getElementById("instructions");
    this.q = this.shadowRoot.getElementById("q");
    this.x = this.shadowRoot.getElementById("x");
    this.gameSelect = this.shadowRoot.getElementById("gameSelect");
    this.roomSelect = this.shadowRoot.getElementById("roomSelect");
    this.roomInput = this.shadowRoot.getElementById("roomInput");
    this.chat = this.shadowRoot.getElementById("chat");
    this.subtitles = this.shadowRoot.getElementById("subtitles");
    this.disappearingLog = this.shadowRoot.getElementById("disappearingLog");
    this.sceneBox = this.shadowRoot.getElementById("sceneBox");
    this.hideLogs = this.shadowRoot.getElementById("hideLogs");
    this.showLogs = this.shadowRoot.getElementById("showLogs");
    /* @__PURE__ */ console.log("Saved elements");
  }
  bindElements() {
    this.q.addEventListener("click", (() => {
      this.showInstructions();
    }).bind(this));
    this.x.addEventListener("click", (() => {
      this.hideInstructions();
    }).bind(this));
    for (let game of this.gameNames) {
      if (game === "lobby")
        continue;
      let option = document.createElement("option");
      option.value = game;
      option.innerHTML = game;
      this.gameSelect.appendChild(option);
    }
    for (let room of this.roomNames) {
      if (room === "lobby")
        continue;
      let option = document.createElement("option");
      option.value = room;
      option.innerHTML = room;
      this.roomSelect.appendChild(option);
    }
    this.gameSelect.addEventListener("change", ((e) => {
      this.gameName = e.target.value;
      location.hash = "#" + this.gameName + "." + this.roomName;
      location.reload();
    }).bind(this));
    this.roomSelect.addEventListener("change", ((e) => {
      if (e.target.value === "+") {
        this.roomInput.classList.remove("hidden");
        this.roomInput.focus();
        return;
      } else {
        this.roomName = e.target.value;
        this.secretRooms.push(this.roomName);
        localStorage.setItem("secretRooms", JSON.stringify(this.secretRooms));
        location.hash = "#" + this.gameName + "." + this.roomName;
        location.reload();
      }
    }).bind(this));
    this.roomInput.addEventListener("change", ((e) => {
      this.roomName = e.target.value;
      location.hash = "#" + this.gameName + "." + this.roomName;
      location.reload();
    }).bind(this));
    this.hideLogs.addEventListener("click", () => {
      localStorage.setItem("hideLogs", "true");
      this.disappearingLog.classList.add("hidden");
      this.hideLogs.classList.add("hidden");
      this.showLogs.classList.remove("hidden");
    });
    this.showLogs.addEventListener("click", () => {
      localStorage.removeItem("hideLogs");
      this.disappearingLog.classList.remove("hidden");
      this.hideLogs.classList.remove("hidden");
      this.showLogs.classList.add("hidden");
    });
    this.scene.display(this.sceneBox);
    let h = localStorage.getItem("hideLogs");
    if (h === "true") {
      this.disappearingLog.classList.add("hidden");
      this.hideLogs.classList.add("hidden");
      this.showLogs.classList.remove("hidden");
    } else {
      this.disappearingLog.classList.remove("hidden");
      this.hideLogs.classList.remove("hidden");
      this.showLogs.classList.add("hidden");
    }
    this.instructions.innerHTML = this.defaultInstructions;
    /* @__PURE__ */ console.log(this.chat);
    this.chat.attachMQTTRTC(this.rtc);
    /* @__PURE__ */ console.log("Bound elements");
  }
  loadGame() {
    const hashParts = location.hash.replace("#", "").split(".");
    this.gameName = hashParts && this.gameNames.includes(hashParts[0]) ? hashParts[0] : localStorage.getItem("game") || "lobby";
    this.roomName = hashParts.length >= 2 ? hashParts[1] : localStorage.getItem("room") || "lobby";
    if (!this.roomNames.includes(this.roomName)) {
      this.roomNames.push(this.roomName);
      this.secretRooms.push(this.roomName);
      localStorage.setItem("secretRooms", JSON.stringify(this.secretRooms));
      let option = document.createElement("option");
      option.value = this.roomName;
      option.innerHTML = this.roomName;
      this.roomSelect.appendChild(option);
    }
    localStorage.setItem("game", this.gameName);
    localStorage.setItem("room", this.roomName);
    location.hash = "#" + this.gameName + "." + this.roomName;
    document.title = this.gameName;
    this.gameSelect.value = this.gameName;
    this.roomSelect.value = this.roomName;
    this.roomInput.classList.add("hidden");
    const src = "../assets/games/" + this.gameName + "/spec.min.json?" + Date.now();
    /* @__PURE__ */ console.log("Loading game", this.gameName, "from", src);
    loadJSON(this.scene, src).then((({ models, metadata }) => {
      this.models = models;
      this.metadata = metadata;
      if (metadata.instructions) {
        let i2 = localStorage.getItem(this.game + "Instructions");
        if (i2 === metadata.instructions) {
          this.hideInstructions();
        } else {
          this.showInstructions();
        }
        this.instructions.innerHTML = metadata.instructions;
      }
    }).bind(this));
  }
  handlers = {
    sync: (data, sender) => {
      /* @__PURE__ */ console.log("Received sync from", sender, data);
    },
    dm: (data, sender) => {
      /* @__PURE__ */ console.log("Received DM from", sender, data);
    },
    chat: (data, sender) => {
      /* @__PURE__ */ console.log("Received group chat from", sender, data);
    },
    moves: (data, sender) => {
      /* @__PURE__ */ console.log("Received moves from", sender, data);
    },
    audio: (data, sender) => {
      /* @__PURE__ */ console.log("Received audio from", sender, data);
    },
    subtitles: (data, sender) => {
      this.subtitles.style.transition = "";
      this.subtitles.style.opacity = 1;
      this.subtitles.innerText = "[" + sender + "] " + data;
      if (this.subtitlesTimeout) {
        clearTimeout(this.subtitlesTimeout);
      }
      ;
      this.subtitlesTimeout = setTimeout(() => {
        this.subtitles.style.transition = "opacity 3s";
        this.subtitles.style.opacity = 0;
      }, 1e3);
    }
  };
  defaultInstructions = `To Move:
    1. Click & drag (then it will snap to position) OR
    2. Click the use arrow keys (then it will snap)

To Rotate:
    1. Double Click OR
    2. Click and use spacebar OR
    3. Right Click and drag to rotate

Software Version: ${window.version}`;
  keydownHandlers = {
    " ": () => {
      this.voiceChat.startStreaming();
    }
  };
  keyupHandlers = {
    " ": () => {
      this.voiceChat.stopStreaming();
    }
  };
  hideInstructions() {
    this.instructions.style.display = "none";
    this.q.style.display = "block";
    this.x.style.display = "none";
    localStorage.setItem(this.game + "Instructions", this.metadata.instructions);
  }
  showInstructions() {
    this.instructions.style.display = "block";
    this.q.style.display = "none";
    this.x.style.display = "block";
    localStorage.removeItem(this.game + "Instructions");
  }
  log(message) {
    const log = this.disappearingLog;
    const div = document.createElement("pre");
    div.classList.add("logs");
    div.classList.add("disappearing");
    div.style.opacity = 1;
    div.innerText = message;
    log.appendChild(div);
    Array.from(log.children).forEach((child, index) => {
      let bottom = parseInt(child.style.bottom) || 0;
      child.style.bottom = bottom + 20 + "px";
    });
    const x = this.hideLogs;
    const p = this.showLogs;
    if (this.fadeHideLogs) {
      clearInterval(this.fadeHideLogs);
      this.fadeHideLogs = null;
    }
    x.style.opacity = 1;
    p.style.opacity = 1;
    setTimeout((() => {
      x.style.opacity = 1;
      p.style.opacity = 1;
      if (this.fadeHideLogs) {
        clearInterval(this.fadeHideLogs);
        this.fadeHideLogs = null;
      }
      this.fadeHideLogs = setInterval(() => {
        x.style.opacity = Math.max((parseFloat(x.style.opacity) || 0) - 0.01, 0);
        p.style.opacity = Math.max((parseFloat(p.style.opacity) || 0) - 0.01, 0);
      }, 100);
    }).bind(this), 2e3);
    setTimeout(() => {
      div.style.opacity = 0;
    }, 1e3);
    setTimeout(() => {
      log.removeChild(div);
    }, 11e3);
  }
};

// src/js/utils/chat.js?v20230820T20:59:36.359Z
var ChatBox = class extends HTMLElement {
  constructor() {
    super();
    this.name = "?";
    this.history = [];
    this.activeUsers = [];
    this.attachShadow({ mode: "open" });
    this.shadowRoot.innerHTML = `
      <style>
        @media only screen and (max-width: 1000px){
          * {
            font-size: 12px; /* twice as big as the default size */
          }

        }
        #chat-container {
          position: fixed;
          bottom: 0.5em;
          right: 0.5em;
          border: 1px solid #ccc;
          background-color: #f9f9f9;
        }
        #chat-header {
          cursor: pointer;
          background-color: #ddd;
          padding: 10px;
          font-weight: bold;
        }
        #chat-body {
          max-height: 40vh;
          overflow: auto;
          display: none;
          padding: 10px;
        }
        #active-users {
          font-size: 0.8em;
        }
        #messages {
          margin-bottom: 10px;
        }
        #voice-button {
            float: right;
        }
        #speaker-button {
            float: right;
        }
        #clear-button {
            float: right;
        }
      </style>
      <div id="chat-container">
        <div id="chat-header">
        Chat
        <input id="chat-name" style="float:right">
        </div>

        <div id="chat-body">
          <div id="active-users"></div>

          <button id="voice-button">\u{1F399}\uFE0F</button>
          <button id="speaker-button">\u{1F50A}</button>
          <button id="clear-button">\u{1F5D1}\uFE0F</button>
          <br/>
          <div id="messages"></div>

          <input id="input-message" type="text" placeholder="Type a message...">
          <button id="send-button">Send</button>
          <button id="emoji-button" style="display: inline-block">\u{1F44B}</button>
        </div>
      </div>
    `;
    this.chatHeader = this.shadowRoot.getElementById("chat-header");
    this.chatBody = this.shadowRoot.getElementById("chat-body");
    this.chatName = this.shadowRoot.getElementById("chat-name");
    this.activeUsersEl = this.shadowRoot.getElementById("active-users");
    this.messagesEl = this.shadowRoot.getElementById("messages");
    this.emojiButton = this.shadowRoot.getElementById("emoji-button");
    this.inputMessage = this.shadowRoot.getElementById("input-message");
    this.sendButton = this.shadowRoot.getElementById("send-button");
    this.voiceButton = this.shadowRoot.getElementById("voice-button");
    this.clearButton = this.shadowRoot.getElementById("clear-button");
    this.speakerButton = this.shadowRoot.getElementById("speaker-button");
    this.clearButton.addEventListener("click", () => {
      this.messagesEl.innerHTML = "";
    });
    this.streaming = false;
    this.voiceButton.addEventListener("click", (() => {
      if (!this.streaming) {
        /* @__PURE__ */ console.log("Starting streaming");
        this.voiceButton.style.backgroundColor = "red";
        this.streaming = true;
        this.rtc.startStreaming();
      } else {
        /* @__PURE__ */ console.log("Stopping streaming");
        this.voiceButton.style.backgroundColor = "";
        this.streaming = false;
        this.rtc.stopStreaming();
      }
    }).bind(this));
    this.muted = true;
    this.speakerButton.addEventListener("click", (() => {
      if (!this.muted) {
        this.muted = true;
        this.rtc.mute();
        this.speakerButton.style.backgroundColor = "";
      } else {
        this.muted = false;
        this.rtc.unmute();
        this.speakerButton.style.backgroundColor = "red";
      }
    }).bind(this));
    this.pingTime = 0;
    this.emojiButton.addEventListener("click", this.ping.bind(this));
    this.chatName.value = localStorage.getItem("name") || "?";
    this.chatName.addEventListener("change", (() => {
      /* @__PURE__ */ console.log("Name changed to " + this.chatName.value);
      localStorage.setItem("name", this.chatName.value);
      if (this.rtc) {
        this.rtc.name = this.chatName.value;
        if (this.rtc.tabID && !this.rtc.name.endsWith(this.rtc.tabID)) {
          this.rtc.name += "_" + this.rtc.tabID;
        }
        this.name = this.rtc.name;
        this.chatName.value = this.name;
      } else {
        this.name = this.chatName.value;
      }
    }).bind(this));
    this.sendMessage = this.sendMessage.bind(this);
    this.attachMQTTRTC = this.attachMQTTRTC.bind(this);
    this.inputMessage.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.ctrlKey) {
        this.sendMessage();
      }
      e.stopPropagation();
    });
    this.chatHeader.addEventListener("click", () => this.toggleChat());
    this.sendButton.addEventListener("click", () => this.sendMessage());
    this.history.forEach((entry) => this.appendMessage(entry));
    this.chatBody.style.display = "block";
  }
  attachMQTTRTC(rtc) {
    this.rtc = rtc;
    this.send = rtc.sendChat.bind(rtc);
    this.name = rtc.name;
    this.chatName.value = this.name;
    rtc.handlers.chat = (message, sender) => {
      this.receive.bind(this)({ data: message, sender, timestamp: Date.now() });
    };
    rtc.handlers.activeUsers = (activeUsers) => {
      this.onActiveUsersChange.bind(this)(activeUsers);
    };
  }
  setHistory(history) {
    this.history = history;
    this.history.forEach((entry) => this.appendMessage(entry));
  }
  send(message) {
    console.warn("No MQTT connection");
  }
  ping() {
    this.sendMessage("\u{1F44B}");
    this.pingTime = Date.now();
  }
  receive({ data, sender, timestamp }) {
    if (data === "\u{1F44B}") {
      let t = Date.now();
      if (t - this.pingTime > 2e3) {
        this.ping();
      }
    }
    this.history.push({ data, sender, timestamp });
    this.appendMessage({ data, sender, timestamp });
  }
  toggleChat() {
    this.chatBody.style.display = this.chatBody.style.display === "none" ? "block" : "none";
  }
  sendMessage(data) {
    data = data || this.inputMessage.value;
    this.send(data);
    this.appendMessage({ data, sender: this.name + "( You )", timestamp: /* @__PURE__ */ new Date() });
    this.inputMessage.value = "";
  }
  appendMessage({ data, sender, timestamp }) {
    const messageEl = document.createElement("div");
    messageEl.textContent = `${sender}: ${data}`;
    this.messagesEl.appendChild(messageEl);
  }
  onActiveUsersChange(activeUsers) {
    /* @__PURE__ */ console.log("Active users: ", activeUsers);
    this.activeUsers = activeUsers;
    this.activeUsersEl.innerHTML = "Active users: " + activeUsers.join(", ");
  }
};

// src/js/index.js
window.version = "v20230820T20:59:36.359Z";
customElements.define("chat-box", ChatBox);
customElements.define("game-board", GameBoard);
